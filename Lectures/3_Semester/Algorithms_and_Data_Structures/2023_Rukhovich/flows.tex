\section{Потоки}
\subsection{Основные определения}
\textbf{Определение.} Сеть --- это ориентированный граф, у каждого ребра которого есть пропускная способность $c(u, v) > 0$, с двумя выделенными вершинами: исток ($s$) и сток ($t$).

\textbf{Определение.} Поток --- функция $f: V \times V \to \mathbb R$ со следующими свойствами:
\begin{itemize}
    \item Антисимметричность.
    \item $f(u, v) \le c(u, v)$ (поток не превосходит пропускную способность ребра).
    \item Если $u \in V \setminus \{s, t\}$, то $\sum_{v \in V} f(u, v) = 0$ (входящий поток равен исходящему).
\end{itemize}

Теперь более программистское определение:

\textbf{Определение.} Поток --- функция $f: E \to \mathbb R_{\ge 0}$ со следующими свойствами:
\begin{itemize}
    \item $f(e) \le c(e)$.
    \item $\sum_{(u, v)} f((u, v) \in E) = \sum_{(v, u) \in E} f((v, u))$.
\end{itemize}

\textbf{Определение.} Величина потока --- $|f|$ --- это величина потока, входящего в сток, или величина потока, исходящего из истока.

\textbf{Корректность.} Просуммируем последнее свойство по всем рёбрам, получим равенство нуля и потока из истока/в сток.

\textbf{Определение.} Остаточная сеть $G_f$ --- это сеть, где из пропускных способностей рёбер вычтен поток $f$ и добавлены обратные рёбра.

\textbf{Определение.} Увеличение потока $f$ на $f'$ --- это функция $(f \uparrow f'): V \times V \to \mathbb R$, такая что $(f \uparrow f')(u, v) = f(u, v) + f'(u, v)$.

\textbf{Лемма.} Увеличение потока является потоком. Просто проверим пункты из определения.

\textbf{Определение.} Насыщенное ребро --- ребро, поток по которому максимален.

\textbf{Определение.} Увеличивающий путь в сети --- путь из истока в сток по ненасыщенным рёбрам.

\textbf{Определение.} Разрез $(S, T)$ --- это разбиение $V = S \sqcup T$, такое что $s \in S$ и $t \in T$.

\textbf{Определение.} Пропускная способность разреза $c(S, T)$ --- это сумма пропускных способностей рёбер, пересекающих его.

\textbf{Определение.} Минимальный разрез --- разрез минимальной пропускной способности.

\textbf{Определение.} Для разреза $(S, T)$ \textit{чистый поток} --- это $f(S, T) = \sum_{u \in S, v \in T} f(u, v)$.

\textbf{Лемма.} Для любого разреза $f(S, T) = |f|$.

\textbf{Доказательство.} По определению $|f| = \sum_{v \in V} f(s, v)$.
Прибавим ноль: $|f| = \sum_{u \in S} \sum_{v \in V} f(s, v)$.
Из-за антисимметричности вклад всех пар $(u, v) \in S \times S$ равен нулю, поэтому $|f| = \sum_{u \in S} \sum_{v \in T} f(u, v) = f(S, T)$.

\sloppy \textbf{Лемма.} Величина потока не превосходит пропускную способность минимального разреза. Действительно, внимательно посмотрим на $|f| = \sum_{u \in S} \sum_{v \in T} f(u, v)$.

\textbf{Теорема.} (Форда-Фалкерсона) Пусть $G$ --- сеть и $f$ --- поток в ней. Следующие утверждения эквивалентны:
\begin{enumerate}
    \item $f$ --- максимальный поток.
    \item $G_f$ не содержит увеличивающие пути.
    \item $|f| = c(S, T)$ для некоторого разреза $(S, T)$.
\end{enumerate}

\textbf{Доказательство.} $1 \Rightarrow 2$ очевидно. $3 \Rightarrow 1$ тривиально.
$2 \Rightarrow 3$: возьмём в качестве $S$ все достижимые из $s$ вершины по ненасыщенным рёбрам.

Таким образом, мы пришли к \textit{методу Форда-Фалкерсона} нахождения максимального потока: сначала ставим нулевой поток по всем рёбрам, далее, пока есть путь по ненасыщенным рёбрам, проталкиваем по нему поток.

\subsection{Алгоритмы поиска максимального потока}
\textbf{Определение.} Целочисленная сеть --- сеть, в которой пропускные способности всех рёбер целочисленные.
В целочисленных сетях алгоритм Форда-Фалкерсона работает за $O(E |f|)$.

\subsubsection{Алгоритм Эдмонса-Карпа} 
(Или ФФ с BFS) Будем искать путь в остаточной сетя не поиском в глубину, а поиском в ширину. Утверждается, что алгоритм работает за $O(VE^2)$.

\textbf{Лемма 1.} Для любой верщины $v$ верно, что в процессе алгоритма Э-К расстояние от истока до $v$ в остаточной сети не уменьшается.

\textbf{Доказательство.} Зафиксируем вершину $v$.
Рассмотрим слои, полученные поиском в ширину. Тогда все рёбра идут либо в непосредственно следующий слой, либо в один из предыдущих слоёв.
Рассмотрим произвольный кратчайший путь из $s$ в $t$ (он не обязан проходить через $v$).
Пустим по нему поток. 
Так как все рёбра идут в направлении строгого увеличения номера слоя, теперь какие-то из рёбер в бóльшие слои исчезли, и какие-то рёбра в меньшие слои появились.
Следовательно, новый путь в $v$ меньшей длины появиться не мог.

\textbf{Лемма 2.} Любое ребро в процессе работы алгоритма Э-К насыщено не более чем $\frac{|V|}{2}$ раз.

\textbf{Доказательство.} Рассмотрим насыщенное ребро $(u, v)$. В каком случае оно может быть насыщено ещё раз?
Для этого должно произойти $\dist(s, u) > \dist(s, v)$, чтобы пустить поток в обратную сторону, а потом снова $\dist(s, v) > \dist(s, u)$, чтобы пустить в направлении $u \to v$.
Следовательно, $\dist(s, v)$ увеличивается хотя бы на 2 при каждом перенасыщении.

Таким образом, каждое из $O(E)$ рёбер насыщается $O(V)$ раз, и для каждого насыщения нужно запустить поиск в ширину за $O(E)$.

\subsubsection{Концепция блокирующих потоков}
\textbf{Определение.} Слоистая сеть --- это сеть $G = (V, E, C, s, t)$, такая что для любого ребра $e \in E$ верно $\dist_G(s, e.start) + 1 = \dist_G(s, e.finish)$.
Иными словами, все рёбра ведут в вершину, лежащую в непосредственно следующем слое.

\textbf{Определение.} Пусть $G = (V, E, C, s, t)$ --- сеть, а $f$ --- поток в ней.
Тогда $f$ называется \textit{блокирующим}, если в сети $G$ не существует пути из $s$ в $t$ по ненасыщенным рёбрам, то есть для увеличения потока приходится отменять уже пущенный поток.

\textbf{Определение.} Концепция блокирующих потоков: пока есть путь из $s$ в $t$ в остаточной сети, запускаем в ней BFS, строим слоистую сеть и строим в этой слоистой сети блокирующий поток.
Это не является алгоритмом Диница, так как мы ничего не говорим про то, как находить блокирующий поток.

\textbf{Теорема.} В концепции блокирующих потов (КБП) выполняется не более, чем $|V|$ итераций.
Данная теорема является следствием более важной:

\textbf{Теорема.} Каждая итерация КБП строго увеличивает расстояние от $s$ до $t$ в остаточной сети.

\textbf{Доказательство.} Рассмотрим одну итерацию. Допустим что по её окончании расстояние не увеличилось.
Тогда из $s$ в $t$ существует путь, проходящий только по ненасыщенным рёбрам, идущим в следующий слой.
Но по этому пути можно пустить поток, поэтому исходный поток не блокирующий --- противоречие.

\textbf{Утверждение.} После того, как мы прошли по ребру и не смогли протолкнуть через него поток, можно его удалить/забыть про него до конца данной итерации.
(Формального доказательства не было)

Вместе с этим утверждением получаем, что для нахождения блокирующего потока можно просто запускать DFS, и он будет работать за $O(|E'| + l + |V|)$, где $E'$ --- оставшиеся рёбра, $l$ --- расстояние от $s$ до $t$ (так как нужно протолкнуть поток) и $|V|$, так как нужно пройти по всем вершинам.

Следовательно, делая суммарно $O(V)$ итераций и проталкивая поток $O(E)$ раз за $O(E)$, получаем $O(VE^2)$.

Отсюда очевидным образом вытекает алгоритм Диница: каждое проталкивание работает за $O(V)$ засчёт того, что мы удаляем лишние рёбра, а по оставшимся проходим на расстояние $O(V)$ до стока.

\subsubsection{Декомпозиция потока}
\textbf{Утверждение.} Поток разбивается на не более, чем $|E|$ путей и циклов.

\subsubsection{Частные случаи алгоритма Диница}
\textbf{Единичная сеть.}

Во-первых, заметим, что при проталкивании потока мы насыщаем сразу все рёбра на пути, поэтому сходу можно сказать, что алгоритм работает за $O(VE)$.

\textbf{Утверждение.} Декомпозиция потока в единичной сети состоит из циклов и рёберно непересекающихся путей.

\textbf{Теорема.} При поиске потока с помощью КБП в единичной сети будет выполнено $O(\sqrt E)$ итераций.

\textbf{Доказательство.} Зафиксируем $k$. Рассмотрим остаточную сеть после $k$ итераций.
Тогда расстояние от $s$ до $t$ не менее $k$.
Пусть $f$ --- текущий поток, $f'$ --- максимальный поток.
Рассмотрим декомпозицию потока $f' - f$: это какие-то циклы и рёберно не пересекающиеся пути длины хотя бы $k$, то есть этих путей не более $\frac{|E|}{k}$.
Но так как каждый путь соответствует ровно одной единице потока, $|f' - f| \le \frac{|E|}{k}$, то есть нам осталось сделать не более $\frac{|E|}{k}$ итераций.
Следовательно, для всех $k$ выполнено, что количество итераций не превосходит $k + \frac{|E|}{k}$.
Возьмём $k = \sqrt{|E|}$.

\textbf{Паросочетание (единичная двудольная сеть)}

Теперь у нас все вершины делятся на два типа: те, в которых входит одно ребро, те, из которых выходит одно ребро.
Второе замечание: через каждую вершину проходит не более одной единицы потока.

\textbf{Теорема.} Будет выполнено $O(\sqrt V)$ итераций.

\textbf{Доказательство.} Теперь у нас все пути в декомпозиции вершинно-непересекающиеся, поэтому можно повторить то же доказательство, что и для единичной сети, взяв $k = \sqrt V$.

Это называется алгоритмом Хопкрофта-Карпа, так как именно они доказали асимптотику, хотя по факту это алгоритм Диница обыкновенный.

\textbf{Почти максимальное паросочетание}

Паросочетание, размер которого --- не менее 95\% от размера максимального паросочетания.

\textbf{Теорема.} (Данилюка) Будем искать максимальное паросочетание в двудольном графе методом КБП. 
Тогда после $k$ итераций размер уже найденного паросочетания будет не менее, чем $\frac{k}{k+1}$ от размера максимального паросочетания.

\textbf{Доказательство.} Всё то же самое: $k$ итераций, декомпозиция потока, который осталось протолкнуть.
В ней все пути будут являться удлинняющими цепочками. 
Более того, длина путей, которые мы находим на $k$-ой итерации --- хотя бы $2k + 3$, так как изначально длина пути --- 3, и после каждой итерации увеличивается хотя бы на 2.
В частности, внутри каждой такой цепочки должно быть хотя бы $k$ рёбер справа налево, то есть в паросочетании.
Следовательно, если $cur_k$ --- это найденный поток после $k$ итераций, то на оставшихся итерациях мы найдём поток величины не более $\frac{cur_k}{k}$.
Тогда ответ не превосходит $cur_k \cdot \frac{k + 1}{k}$.
Таким образом, спустя 19 итераций мы найдём 95\% паросочетания.

\subsection{Паросочетания}
(Да, здесь что-то не так с хронологией)

\textbf{Утверждение.} Максимальное паросочетание --- это насыщенные рёбра в остаточной сети максимального потока. Оба неравенства проверяются напрямую.

\textbf{Утверждение.} Алгоритм Куна --- это оптимизированный поиск максимального потока.
Действительно, удлинняющая цепь --- это в точности путь по ненасыщенным рёбрам.

\textbf{Лемма.} При поиске потока методом Форда-Фалкерсона не может быть такого, что после $k$-ой итерации в остаточной сети нет пути от $v$ до $t$, а после $(k+1)$-ой --- есть.

\textbf{Доказательство.} От противного: рассмотрим новопоявившийся путь $A$.
Раз он появился только сейчас, мы должны были пустить по нему отрицательный поток, то есть найти путь по ненасыщенным рёбрам $B$.
Рассмотрим первую вершину на пути $A$, лежащую на пути $B$: из неё есть путь в $t$ по ненасыщенным рёбрам, и в неё есть путь из $v$.

\textbf{Лемма.} (Холла) Пусть $N(U)$ --- множество вершин, инцидентных вершинам $u \in U$.
Тогда совершенное паросочетание существует тогда и только тогда, когда для всех $U \subset V$ верно $|N(U)| \ge |U|$.

\textbf{Доказательство.} $\Rightarrow$ очевидно. $\Leftarrow$: от противного, пусть для $u \in L$ не нашлась пара.
Тогда если запустить из итерацию алгоритма Куна, мы посетим какие-то вершины $X \subset L$ и $Y \subset R$.
Как вершина $v \in X$ могла там оказаться? Либо $v = u$, либо мы пришли в неё из вершины $r \in Y$.
По определению паросочетания отображение $r \mapsto v$ инъективно, и, так как оно не сюръективно (из-за $u \in X$), $|X| < |Y|$.
Остаётся понять, что $Y$ --- это в точности $N(X)$.

\textbf{Задача.} Доказать, что в $d$-регулярном двудольном графе существует полное паросочетание.
Доказывается аналогично теореме Холла.

\textbf{Определение.} $\alpha(G)$ --- размер максимального независимого множества.

\textbf{Определение.} $\tau(G)$ --- размер минимального вершинного покрытия (каждое ребро графа инцидентно хотя бы одной вершине из этого множества).

\textbf{Определение.} $\pi(G)$ --- размер максимального паросочетания.

\textbf{Свойство 1.} $\tau(G) = |V| - \alpha(G)$. Будет следовать из следующего:

\textbf{Свойство 2.} $\forall V' \subset V$ ($V'$ --- вершинное покрытие $\iff$ $V \setminus V'$ --- независимое множество).

\textbf{Доказательство.} Напишем определение для вершинного покрытия $V'$: $\forall (u, v) \in E$ $(u \in V' \vee v \in V')$ или $(u \not\in V \setminus V' \vee v \not\in V \setminus V')$ или же $V \setminus V'$ --- независимое множество.

\textbf{Свойство 3.} $\pi(G) \le \tau(G)$.

\textbf{Теорема.} (Кёнига) В двудольном графе $G$ верно $\pi(G) = \tau(G)$.

\textbf{Доказательство.} Мы уже знаем, что $\pi(G) \le \tau(G)$, поэтому достаточно построить покрывающее множество размера $\pi(G)$.
Добавим направление для рёбер в графе: рёбра из паросочетания идут влево, остальные --- вправо.
Запустим поиск в глубину из левых вершин, не покрытых паросочетанием.
Разобьём все вершины на 4 множества: $R^+, R^-, L^+, L^-$, где множества с плюсами --- это те вершины, которые обошёл поиск, а с минусом --- остальные.

Тогда утверждается, что $L^- \cup R^+$ --- это и есть искомое вершинное покрытие размера $\pi(G)$.
Вершинным покрытием оно очевидно является, так как в нём могут не лежать только рёбра между $L^+$ и $R^-$: если ребро направлено влево, то мы могли прийти в вершину из $L^+$ только из вершины в $R^-$, а вправо быть не может, так как вершину из $R^-$ мы не посетили.
Размер совпадает из соображения, что все вершины из $L^-$ и из $R^+$ лежат в паросочетании ($L^-$ --- по определению, $R^+$ --- если не лежит, то мы нашли удлинняющую цепь, так как стартовали из непокрытой вершины), и ни одно из рёбер паросочетания не лежит между двумя вершинами из этих множеств.

\textbf{Определение.} Пусть $\left<A, \le \right>$ --- конечное ЧУМ. Тогда последовательность $a_1, \dots, a_k$ называется \textit{цепью}, если $a_1 \le a_2 \le \dots \le a_k$.

\textbf{Определение.} Множество вершин $\{a_1, \dots, a_k\} \subset A$ называется \textit{антицепью}, если $\forall i, j~a_i \not\le a_j$.

\textbf{Теорема.} (Дилворда) В конечном ЧУМе $\left< A, \le \right>$ количество цепей в минимальном разбиении на цепи в точности совпадает с максимальным размером антицепи.

\textbf{Доказательство.} Докажем нестрогие неравенства в обе стороны. В силу транзитивности графа количество покрывающих цепей не может быть меньше размера антицепи, потому что в этом случае какие-то два элемента антицепи окажутся в одной цепи.
Раздвоим все вершины $a_i$ в вершины $l_i$, $r_i$ и сопоставим ребру $(a_i, a_j)$ исходного графа ребро $(l_i, r_j)$ в новом графе $A'$.
Пусть $f(A)$ --- минимальное число цепей, необходимое для покрытия $A$.
Так как цепь длины $k$ содержит $k - 1$ ребро, суммарно все цепи содержат $|A| - f(A)$ рёбер.
Более того, каждое ребро цепи в $A$ соответствует ребру паросочетания в $A'$, и они попарно не пересекаются.
Следовательно, $|A| - f(A) \le \pi(A')$, и пример с равенством строится тривиально.

Остаётся построить независимое множество $S$ в графе $A$ размера $|A| - \pi(A')$.
Положим в $S$ все вершины из $A$, которые не соответствуют ни одной вершине из минимального вершинного покрытия.
Тогда $S$ --- независимое множество, как подмножество дополнения к минимальному вершинному покрытию, и $|S| \ge |A| - \tau(A') = |A| - \pi(A') = f(A)$.

\subsection{Алгоритмы в целочисленных сетях}
Пусть все пропускные способности рёбер целочисленные и не превосходят $C$. В частности, максимальный поток не превосходит $|E|C$.

Тогда можно пихать поток величины $C$, $\frac{C}{2}$, $\frac{C}{4}$ и так далее и улучшить асимптотику.
Найдём эту асимптотику. Пусть мы проталкивали поток величины $2^k$, и он перестал влезать.
Тогда у нас появился разрез, через который проходят рёбра с оставшейся пропускной способностью менее $2^k$, то есть суммарный вес разреза меньше $|E| \cdot 2^k$.
Следовательно, поток в оставшейся сети менее $|E| \cdot 2^k$.

Если использовать алгоритм Форда-Фалкерсона, то у нас будет $\log(C)$ итераций, и каждая итерация будет работать за $O(|E|^2)$.

Что получится, если написать алгоритм Диница с масштабированием?
Вспомним, что, если расстояние от истока до стока равно $l$, то один запуск поиска в глубину отрабатывает за $l + |E'|$, где $E'$ --- множество удалённых рёбер.
Если просуммировать это по $k$ запускам, то получится
\[
    k|E| + \sum_{i=1}^{k} l_i kol_i \le k|E| + |V| \sum_{i=1}^{k} kol_i \le |V| \cdot |E| + |V| \sum_{i=1}^{k} kol_i = O(VE).
\]
Здесь $kol_i$ --- количество путей, по которым мы протолкнули поток.
Последнее равенство следует из того, что максимальный возможный поток в сети не превосходит $|E| 2^k$, и мы проталкиваем $2^k$.
Следовательно, вместе с масштабированием алгоритм Диница работает за $O(VE \log(C))$.

\subsubsection{Оптимизация до $O(VE \log(V))$}
Заметим, что в ходе работы алгоритма Диница из каждой вершины выходит только одно ребро, которое нас интересует, и самая медленная часть --- обновление рёбер при проталкивании потока.
Если рассмотреть эти рёбра, то получится лес, в котором нам нужно уметь:
\begin{enumerate}
    \item Удалять рёбра (при насыщении).
    \item Добавлять рёбра (после удаления насыщенного ребра).
    \item Проверять, является ли $s$ потомком $t$.
    \item Находить минимум на пути от $s$ до $t$.
    \item Вычитать на пути от $s$ до $t$.
\end{enumerate}
Всё это умеет делать Link-Cut Tree, и эти операции заменяют поиск в глубину, так что поиск блокирующего потока работает за $O(E \log(V))$.

\subsubsection{Оценки Карзанова}
\textbf{Определение.} Пусть $G = (V, E, C, s, t)$ --- это сеть. Пусть $v$ --- вершина, не являющаяся ни стоком, ни истоком.
Тогда 
\begin{itemize}
    \item Входящий потенциал --- $p_{in}(v) = p_{G,in}(v) = \sum_{(u, v) \in E} c((u, v))$.
    \item Исходящий потенциал --- $p_{out}(v) = p_{G,out}(v) = \sum_{(v, u) \in E} c((v, u))$.
    \item Потенциал --- $p(v) = p_G(v) = \min(p_{in}(v), p_{out}(v))$.
    \item Потенциал сети --- $P = P_G = \sum_{v \in V \setminus \{s, t\}} p(v)$.
\end{itemize}

\textbf{Лемма.} Пусть $G$ --- сеть, а $f$ --- поток в ней. Тогда для любой $v \in V \setminus \{s, t\}$ верно $p_{G, in}(v) = p_{G_f, in}(v)$, $p_{G, out}(v) = p_{G_f, out}(v)$, $p_{G}(v) = p_{G_f}(v)$.

\textbf{Доказательство.} При проталкивании потока по рёбрам $(u, v)$ и $(v, w)$ уменьшается пропускная способность ребра $(v, w)$, а у ребра $(v, u)$ увеличивается на то же значение, поэтому сумма в вершине $v$ не изменилась.

\textbf{Теорема.} (Первая теорема Карзанова) Пусть $G$ --- произвольная целочисленная сеть.
Тогда любой алгоритм поиска максимального потока в сети $G$, основанный на концепции блокирующих потоков, выполнит $O(\sqrt {P_G})$ итераций.

\textbf{Доказательство.} Выполним $\sqrt{P_G}$ итераций алгоритма. Докажем, что в полученной остаточной сети величина максимального потока не превосходит $\sqrt{P_G}$.
Рассмотрим оставшийся максимальный поток и декомпозируем его на пути и циклы.
Длина каждого этого пути --- хотя бы $\sqrt{P_G}$.
В силу целочисленности сети каждый путь будет брать на себя хотя бы $\sqrt{P_G}$ единиц потенциала, так как потенциал --- это сумма максимально возможных потоков через каждую вершину.
Следовательно, этих путей не более $\sqrt{P_G}$.

\textbf{Теорема.} (Вторая теорема Карзанова) Пусть $G$ --- целочисленная сеть без кратных рёбер с пропускными способностями, не превосходящими $C$.
Тогда любой алгоритм поиска максимального потока в сети $G$, основанный на концепции блокирующих потоков, выполнит $O(\sqrt[3]{C|V|^2})$ итераций.

\textbf{Доказательство.} Сделаем $k$ итераций и оценим величину оставшегося потока.
Рассмотрим слоистую сеть. По теореме Форда-Фалкерсона любой разрез в этой сети не меньше максимального потока.
Рассмотрим разрез между $l$-ым и $(l+1)$-ым слоем. Тогда количество рёбер между ними не превосходит $2|V_l| \cdot |V_{l+1}|$ (между парой вершин может быть два ребра с противоположными направлениями).

Таким образом, $f_{\text{ост}} \le 2C \cdot \min_{l=1}^{k} (|V_l| \cdot |V_{l+1}|)$.
Воспользуемся неравенством Коши: 
\[
    f_{\text{ост}} \le 2C \cdot \min_{l=1}^{k} \left( \left(\frac{|V_l| + |V_{l+1}|}{2} \right)^2 \right) = \frac{C}{2} \cdot \min_{l=1}^{k} (|V_l| + |V_{l+1}|)^2 \le
\]
\[
    \le \frac{C}{2} \left( \frac{\sum_{l=1}^{k} (|V_l| + |V_{l+1}|)}{k} \right)^2 \le \frac{C}{2} \left( \frac{2|V|}{k} \right)^2 = 2C \cdot \frac{|V|^2}{k^2}.
\]
То есть для всех $k$ верно, что количество итераций не превосходит $k + 2C \frac{|V|^2}{k^2}$.
Возьмём $k = \sqrt[3]{C |V|^2}$, получаем искомую оценку.

\textbf{Пример.} Дан граф $G = (V, E)$, мы хотим найти в нём подграф $G' = (V', E')$, в котором отношение $\frac{|E'|}{|V'|}$ максимально (подграф максимальной плотности).

Применим бинарный поиск по ответу. Будем искать ответ на вопрос: существует ли подграф с $|E'| \ge M |V'|$.

Есть похожая задача: даны $n$ пар чисел $(a_i, b_i)$, выбрать $k$ из них так, чтобы максимизировать $\frac{\sum a}{\sum b}$.
Можно сделать бинарный поиск по ответу, тогда 
\[
    \frac{\sum a}{\sum b} \ge M \iff \sum a \ge \sum kb \iff \sum (a - kb) \ge 0.
\]

Сделаем минимальный разрез в этом графе так, чтобы в первой половине лежали вершины из $V'$, во второй --- из $V \setminus V'$.
Сделаем всем рёбрам пропускную способность $-1$, а рёбрам в сток --- $M$. 
Тогда величина разреза равна $M|V'| - $ (количество рёбер, пересекающих разрез).
Это равно $M|V'| + 2|E'| - \sum \deg(v')$.
Такая величина не очень помогает, поэтому сделаем рёбрам в сток пропускную способность $(-M + \deg(v))$.
С такими пропускными способностями минимальный разрез --- минимум величины $(-M|V'| + 2|E'|)$.
В очередной раз не сошлось, так как мы хотим проверить неравенство $M|V'| < 2|E'|$, но это чинится домножением всех пропускных способностей на $-1$.

Однако этот разрез нельзя свести к поиску потока, так как рёбра имеют потенциально отрицательные пропускные способности и нет рёбер из истока.
Это нетрудно исправить: добавим во все вершины рёбра из стока величиной $+\infty$ и к пропускным способностям рёбер в сток добавим $+\infty$.
Величина разреза не изменилась, но теперь в этой сети можно искать поток.
Также можно вместо бесконечности добавить рёбра из стока в вершину $v$ величины $\deg(v)$.

\subsubsection{Теоремы Менгера}
\textbf{Теорема.} (О рёберной двойственности) Между вершинами $u$ и $v$ существует $L$ рёберно непересекающихся путей тогда и только тогда, когда после удаления любых $L - 1$ рёбер существует путь из $u$ в $v$.

\textbf{Доказательство.} $\Rightarrow$: очевидно. 
$\Leftarrow$: пусть $u$ --- исток, $v$ --- сток. Назначим всем рёбрам пропускную способность 1 и найдём максимальный поток.
По теореме Форда-Фалкерсона его величина равна минимальному разрезу.
По условию при удалении $L - 1$ ребра в этом разрезе между $u$ и $v$ всё ещё останется путь, то есть величина потока --- хотя бы $L$, то есть $L$ рёберно непересекающихся путей, так как сеть единичная.

\textbf{Теорема.} (О вершинной двойственности) Между вершинами $u$ и $v$ существует $L$ вершинно непересекающихся путей тогда и только тогда, когда после удаления любых $L - 1$ вершин существует путь из $u$ в $v$.

\textbf{Доказательство.} Раздвоим вершину, чтобы ограничить поток через неё.

\subsection{Проталкивание предпотока или технология Голдберга}
\subsubsection{Концепция}
Мы будем разрешать себе в некоторые моменты времени пускать неправильный поток для улучшения асимптотики.

\textbf{Определение.} Предпоток $f$ в сети $G = (V, E, c, s, t)$ --- это функция $f: E \to \mathbb R$, такая что
\begin{itemize}
    \item Для всех рёбер поток через него не превосходит пропускную способность.
    \item Для всех вершин $v$, кроме стока и истока, верно, что сумма входящего потока больше суммы исходящего.
\end{itemize}

\textbf{Определение.} Высота $h: V \to \mathbb Z_{\ge 0}$, такая что
\begin{itemize}
    \item $h(s) = |V|$.
    \item $h(t) = 0$.
    \item У остальных вершин высоты могут меняться, \textbf{не уменьшаясь}, однако для любого ребра $e$ в остаточной сети $E_f$, такого что $c_f(e) > 0$, верно $h(e.finish) \ge h(e.start) - 1$.
        То есть рёбра могут спуститься на высоту на один меньше, остаться на той же высоте или подняться.
\end{itemize}

\textbf{Определение.} Избыток вершины $v$ --- $\excess(v)$ --- разность входящего и исходящего потока.

Изначально $h(v) = 0$ для всех $v \ne s$ и мы насыщаем все рёбра, инцидентные $s$.
Далее изменяем предпоток и высоты, пока хотя бы у одной вершины $v \not\in \{s, t\}$ есть ненулевой избыток.

Рассмотрим предпоток, удовлетворяющий условиям на высоту с нулевыми избытками.

\textbf{Утверждение.} Это поток, очевидно.

\textbf{Утверждение.} Этот поток максимален. Допустим, что он не максимален, тогда существует простой путь в остаточной сети из $s$ в $t$.
В этом пути не более $|V| - 1$ рёбер, но тогда $h(t) \ge 1$ --- противоречие.

Введём дополнительное ограничение: изменять предпоток и высоты разрешено исключительно с помощью функций $\push$ и $\relabel$.

\textbf{Определение.} $\push(e)$ --- функция от ребра, проталкивающая по данному ребру поток. Требования:
\begin{itemize}
    \item $\excess(e.start) > 0$.
    \item $c_f(e) > 0$.
    \item $h(e.finish) = h(e.start) - 1$.
\end{itemize}
Всё, что она делает --- проталкивает поток величины $\min(\excess(e.start), c_f(e))$.

\textbf{Определение.} Вызов $\push(e)$ называется \textit{насыщающим}, если после него $f(e) = c(e)$.

\textbf{Определение.} $\relabel(v)$ --- функция от вершины, которая ``поднимает`` вершину. Требования:
\begin{itemize}
    \item $\excess(v) > 0$.
    \item Из $v$ нельзя сделать $\push$ ни по одному ребру.
\end{itemize}
Выполняет присвоение 
\[
    h(v) = 1 + \min_{\substack{e \in E_f \\ c_f(e) > 0 \\ e.start = v}}(h(e.finish)).
\]
Нетрудно заметить, что высота строго увеличится.
Хотя бы одно ребро найдётся, потому что подходит ребро, по которому в вершину входит избыток.

\textbf{Лемма.} Если $\excess(v) > 0$, то в остаточной сети $G_f$ существует путь из $v$ в $s$ (не наоборот!) по ненасыщенным рёбрам.

\textbf{Доказательство.} Допустим, что это неправда. Запустим DFS из $v$ по обратным рёбрам. Тогда суммарный избыток у всех посещённых вершин строго больше нуля, так как он может быть отрицательным только у истока.
Но теперь заметим, что рёбра, лежащие полностью в посещённой компоненте, не меняют суммарный избыток.
Следовательно, существует ребро вне данной компоненты, входящее в вершину из этой компоненты, то есть мы посетили не всё, что могли --- противоречие.

\textbf{Следствие.} Если $\excess(v) > 0$, то $h(v) \le 2|V| - 1$. Пройдём по пути из леммы, в этом пути не более $|V| - 1$ рёбер и мы пришли в $s$ --- вершину высоты $|V|$.

\textbf{Следствие.} Предыдущее следствие верно для всех вершин. Высота могла увеличиться только после $\relabel$-а, а это значит, что у вершины был избыток, и после увеличения у неё всё ещё остаётся избыток, так что она подходит под следствие.

\textbf{Следствие.} $\relabel$ вызывается $O(|V|^2)$ раз, так как он увеличивает высоту, и высота у вершины ограничена.
Более того, суммарно они работают за $O(VE)$.

Рассмотрим одно ребро $e$. Пусть мы сделали насыщающий $\push$ в одну сторону, потом --- в обратную.
Заметим, что для этого нужно было поднять $e.finish$ хотя бы на две единицы, чтобы сделать $\push$ в обратную сторону.
Следовательно, насыщающих $\push$-ей $O(VE)$ суммарно.

Рассмотрим на $\push$-и между соседними $\relabel$-ами. Заметим, что ненасыщающий $\push$ удаляет избыток вершины, а после насыщающего это ребро останется насыщенным до следующего $\relabel$-а.
Поэтому насыщающих не более $|E|$, а для ненасыщающих введём потенциал $\Phi := \sum_{\substack{v \in V \setminus \{s, t\}\\ \excess(v) > 0}} h(v)$.
Тогда ненасыщающие $\push$-и уменьшают потенциал, а насыщающие увеличивают не более, чем на $2|V| - 2$ ввиду ограничения на высоту.
Что насчёт $\relabel$? Из доказанного выше, все вызовы $\relabel$ суммарно увеличивают потенциал не более, чем на $(|V| - 2)(2|V| - 1)$.

\textbf{Теорема.} Ненасыщающих $\push$-ей не более $4|V|^2(|V| + |E|)$. Следует из того, что между двумя $\relabel$-ами не более $|E|$ насыщающих $\push$-ей, поэтому потенциал не превосходит $4|V|^2(|V| + |E|)$, и ненасыщающий $\push$ его уменьшает.

Таким образом, если это аккуратно написать, можно получить алгоритм за $O(V^2E)$, так как всё, что нужно поддерживать, --- из каких вершин можно сделать $\relabel$.

\subsubsection{Оптимизация до $O(V^3)$}
Аналогично алгоритму Диница будем поддерживать в вершине указатель на ребро, по которому мы можем пройти.
Теперь мы не будем пользоваться операциями $\push$ и $\relabel$, а будем только использовать операцию $\discharge(v)$.
Реализация такая:
\begin{verbatim}
    while excess[v] > 0 {
        if (it[v] != network[v].end()) {
            if (mayPush(*it[v])) {
                push(*it[v]);
            } else {
                it[v]++;
            }
        } else {
            relabel(v);
            it[v] = network[v].begin();
        }
    }
\end{verbatim}
Для доказательства корректности хочется сказать, что после того, как мы пропустили ребро, оно нас больше не интересует (как в Динице).
Действительно, после насыщения оно не могло отнасытититься, так что это не проблема.
Если оно не подходило по высоте, то высота у конца ребра больше, а это чиниться только $\relabel$-ом из текущей вершины.

Теперь нам только нужно поддерживать вершины с избытком для того, чтобы вызывать из них $\discharge$.
Но всё равно каждое ребро мы просматриваем $|V|$ раз при $\relabel$-ах концов, и дополнительно суммарно $|V|^2|E|$ из-за ненасыщающих $\push$-ей.
Очевидно, что проблема в ненасыщающих проталкиваниях, именно их и будем оптимизировать.

\textbf{Алгоритм 1.} (По высоте) Будем выписывать все вершины, сортировать их по убыванию высоты и вызывать $\discharge$ от всех вершин в этом порядке.
Сортировка работает за $O(V)$, так как можно подсчётом.
Нас интересует только количество ненасыщающих проталкиваний и количество фаз.
Начнём с того, что в каждой фазе мы делаем не более $|V|$ ненасыщающих проталкиваний, так как они обнуляют избыток.
Докажем, что фаз $O(V^2)$.
Заметим, что после прохода $\discharge$-ами у нас либо произошёл $\relabel$ в какой-то вершине (таких фаз $O(V^2)$), либо у всех вершин закончился избыток (так как в порядке убывания высот), и алгоритм завершается.
Следовательно, алгоритм будет работать за $O(V^3)$, ибо остальные части работают за $O(VE)$.

\textbf{Алгоритм 2.} (Поднять вверх) Будем брать вершины в случайном порядке и идти слева направо, вызывая $\discharge$.
Если в какой-то вершине произошёл $\relabel$, перенесём её в начало и пойдём заново.
Это официальный алгоритм и утверждается, что он работает.

\textbf{Лемма.} Пусть в процессе прохода есть ребро $u \to v$, по которому можно сделать $\push$ (назовём его хорошим).
Тогда позиция $u$ меньше позиции $v$ в списке вершин.

\textbf{Доказательство.} В начале алгоритма хороших рёбер вообще нет. А потом если оно появилось, то оно выходит из вершины, которую мы отправили в начало.
Если же мы конец хорошего ребра отправили в начало, то оно перестало быть хорошим.

Следовательно, мы можем просто вызывать $\discharge$, аналогично первому алгоритму: оценка количества фаз та же самая, так как поток идёт слева направо.

\textbf{Алгоритм 3.} (С очередью) Заведём очередь, будем проходить по ней и вызывать $\discharge$ от всех вершин.
Откуда будут браться вершины в этой очереди? 
Во-первых, положим в начале туда все вершины.
Во-вторых, будем класть в неё конец тех рёбер, которые мы при $\push$-е не насытили.

Для доказательства введём потенциал $\Phi = \max_{\substack{v \in V \setminus \{s, t\} \\ \excess(v) > 0}}(h(v))$.
Заметим, что при $\relabel$ он увеличивается не более, чем на единицу, а при $\push$-e он может уменьшится, а увеличиться не может, так как проталкиваем в вершины меньшей высоты.
Рассмотрим фазы, аналогично поиску в ширину. Если в фазе произошёл $\relabel$, то таких фаз мало, а если не произошёл, то потенциал должен был уменьшиться, поэтому между двумя $\relabel$-ами их $O(V)$.

\textbf{Алгоритм 4.} Максимально наивно: просто пока есть вершины с избытком, проходим по всем вершинам и вызываем $\discharge$.
Доказывается тем же потенциалом, что и третий.

\textbf{Алгоритм 5.} (Malhotra-Kumar-Maheshwari) Рассмотрим слоистую сеть и вспомним потенциалы Карзанова: $p(v) = \min(p_{in}(v), p_{out}(v))$.
Возьмём вершину с минимальным потенциалом и протолкнём поток в сток по прямым и в исток по обратным рёбрам.
После этого удалим эту вершину и пересчитаем потенциалы.
Протолкнуть мы сможем по определению потенциала, так повторяем, пока потенциал ненулевой.

\subsection{Максимальный поток минимальной стоимости}
\subsubsection{Циркуляция}
\textbf{Определение.} Циркуляция в сети $G$ --- поток величины 0.

\textbf{Утверждение.} Любую циркуляцию можно декомпозировать на не более чем $|E|$ циклов.

\textbf{Определение.} Циркуляция минимальна, если её стоимость минимально возможная.

\textbf{Определение.} Циркуляция локально оптимальна, если в остаточной сети нет циклов отрицательной стоимости.

\textbf{Теорема.} Циркуляция минимальная тогда и только тогда, когда она локально оптимальна.

\textbf{Доказательство.} $\Rightarrow$: очевидно. 
$\Leftarrow$. Пусть $f$ --- оптимальная циркуляция, а $f'$ --- минимальная, причём $\cost(f') < \cost(f)$.
Тогда в остаточной сети $G_f$ существует циркуляция $f' - f$, и $\cost(f' - f) = \cost(f') - \cost(f) < 0$.
Корректность: если пустили отрицательное значение по ребру, то по обратному пустили положительное.
Тогда в декомпозиции $f' - f$ на циклы найдётся хотя бы один цикл отрицательной стоимости --- противоречие, так как в $f$ их нет.

\textbf{Определение.} Потенциал --- функция $p: V \to \mathbb R$, такая что приведённая стоимость ребра $e$ --- это $\cost_p(e) := \cost(e) + p(e.start) - p(e.finish)$.

\textbf{Утверждение.} Пусть $\rho$ --- путь от $u$ до $v$. Тогда $\cost_p(\rho) = \cost(\rho) + p(u) - p(v)$.

\textbf{Утверждение.} Если $\rho$ --- цикл, то $\cost_p(\rho) = \cost(\rho)$.

\textbf{Определение.} Потенциал $p$ неотрицательный, если $\forall e \in E~(e.cap > 0 \rightarrow \cost_p(e) \ge 0)$.

\textbf{Теорема.} Неотрицательный потенциал существует тогда и только тогда, когда в сети нет циклов отрицательного веса.

\textbf{Метод Клейна.}
Переходим к алгоритму поиска минимальной циркуляции. Пусть у графа все пропускные способности равны единице.
Будем добавлять рёбра по-одному, обновляя потенциал.
Инвариант: до добавления ребра циклов отрицательного веса не было.
А именно, после добавления ребра $(u, v)$ будем определять $p(w) = \dist_{G_f}(v, w)$ без учёта нового ребра для достижимых из $v$ вершин $w$, а для остальных --- просто прибавим константу, чтобы цены стали неотрицательными.
Теперь, если цикл отрицательного веса не появился, мы продолжаем добавлять рёбра.
Иначе пустим по этому циклу единичный поток.

Утверждение: после этого все приведённые веса рёбер неотрицательны.
Рассмотрим, как они изменились.
Если ребро не лежало на отрицательном цикле, то приведённый вес не изменился.
А если лежало, то с новым потенциалом приведённые веса всех рёбер, кроме $(u, v)$, равны нулю, поэтому после проталкивания потока они развернутся, ноль останется нулём, а ребро $(u, v)$ станет положительным.

Асимптотика: каждое ребро мы добавляем один раз и ищем кратчайший путь алгоритмом Дейкстры, поэтому $O(E^2 \log(V))$.
Если рёбра не единичные, то всё умножается на $C$: из каждого ребра пропускной способности $c$ мы делаем $c$ единичных рёбер.

\subsubsection{Максимальный поток минимальной стоимости}
Эта задача очень легко сводится к циркуляции: добавим из стока в исток ребро пропускной способностью $+\infty$ с ценой $-\infty$.
Теперь запускаем на этой сети алгоритм поиска минимальной циркуляции.
Заметим, что мы получили в точности тот самый жадный алгоритм.
В частности, фиктивное ребро можно добавить в конце, тогда проталкивать потоки не придётся, и получится асимптотика $O(VE + |f| E \log(V))$.

\subsubsection{Венгерский алгоритм}
Рассмотрим полный двудольный граф, у которого все рёбра имеют какую-то стоимость.
Мы хотим найти совершенное паросочетание минимальной стоимости.
Пусть $L$ и $R$ --- доли графа, $u: L \to \mathbb R$, $v: R \to \mathbb R$ --- потенциалы на долях, $a[i][j]$ --- стоимость ребра из $i$ в $j$.
Будем поддерживать инвариант $a[i][j] - u[i] - v[j] \ge 0$.

\textbf{Определение.} Ребро $(i, j)$ \textit{жёсткое}, если $a[i][j] - u[i] - v[j] = 0$.

Наша цель: подобрать потенциалы так, чтобы выполнялся инвариант и существовало совершенное паросочетание на жёстких рёбрах.

\textbf{Утверждение.} Такое паросочетание --- искомое.

Будем делать всё в точности, как в алгоритме Куна, но теперь в DFS-е мы будем ходить только по жёстким рёбрам.
По утверждению выше, полученное в итоге паросочетание из жёстких рёбер искомое.

Теперь должны возникать логичные вопросы: почему найдётся удлинняющая цепь, откуда брать потенциалы и прочее.
Если ребро не нашлось, то будем подкручивать потенциалы, чтобы нашлось.
Пусть $L^+, R^+$ --- посещённые вершины, $L^-, R^-$ --- непосещённые.
Пусть $\Delta$ --- минимум стоимости ребра $(i, j)$ с учётом потенциала, где $i \in L^+$ и $j \in R^-$.
Сделаем так, чтобы это ребро стало жёстким. А именно, прибавим $\Delta$ ко всем $u[i]$, где $i \in L^+$, и вычтем из всех $v[j]$, где $j \in R^+$.
Теперь можно посмотреть на рёбра из всех пар множеств и проверить, что жёсткие рёбра остались жёсткими, инвариант сохранился и рёбра веса $\Delta$ стали жёсткими.
Так как мы добавили хотя бы одну вершину в $R^+$, такие добавления будут выполнены $O(V)$ раз, поэтому итоговая асимптотика --- ($V$ вершин, в каждой из них запускаем $V$ DFS из алгоритма Куна) $O(V^4)$.

В данной вариации есть одно место, которое мы делаем за $O(V^2)$, и которое можно оптимизировать, --- нахождение $\Delta$ и последующий перезапуск DFS-а.
Положим $min\Delta[j] = \min_{i \in L^+}(a[i][j] - u[i] - v[j])$ для $j \in R^-$.
Данную величину нетрудно поддерживать в DFS-е и при обновлении потенциалов.
А DFS оптимизировать довольно просто, так как между запусками из одной вершины можно не очищать список посещённых вершин, а просто запускаться из той вершины, которая стала достижима после обновления потенциалов.
Итоговое время работы --- $O(V^3)$.

\subsection{Глобальный разрез}
Пусть нам дан граф с неотрицательными весами.
Мы хотим найти два множества $S$ и $T$, такие что $S \sqcup T = V$, $S, T \ne \varnothing$ и $f(S, T)$ минимально.
Можно просто зафиксировать первую вершину, перебрать вершину в другой доли и найти максимальный поток, получая $O(V^4)$.

\subsubsection{Алгоритм Штор-Вагнера}
Не Штора-Вагнера.

Пусть у нас есть изначально пустое множество $A$.
Будем добавлять вершины в специальном порядке $v_1, \dots, v_n$ так, чтобы минимальным разрезом между $v_{n-1}$ и $v_n$ было множество $\{v_1, \dots, v_{n-1}\}$.
После этого у нас есть два варианта: либо это искомый разрез, либо объединяем эти две вершины и запускаем заново.
То есть либо мы нашли минимальный разрез, и он между вершинами $v_{n-1}$ и $v_n$, либо он не минимален, и тогда во всех остальных разрезах они будут вместе.

В каком же порядке брать вершины? Пусть $v_0$ --- произвольная вершина, а $v_i = \argmax_{u \in V \setminus A_i}(w(u, A_i))$, где $A_i = \{v_1, \dots, v_{i-1}\}$ и $w(u, S) = \sum_{v \in S} w(u, v)$ --- сумма весов рёбер.
Об этом можно думать, как о самой ``тесно связанной`` вершиной со множеством $A_i$.

\textbf{Доказательство корректности.} Пусть $s = v_{n-1}$, $t = v_n$, $C$ --- какой-то разрез между $s$ и $t$. Докажем, что наш разрез не хуже $C$.

\textbf{Определение.} Вершина $v_i$ \textit{критическая}, если $v_{i-1}$ и $v_i$ лежат в разных долях $C$.
Как об этом думать: сначала идёт несколько вершин справа, потом слева и так далее, критические вершины --- это первые вершины в этих отрезках.

Положим $C_i$ --- множество рёбер $(x, y) \in C$, таких что $x, y \in A_i \cup \{v_i\}$. Иными словами, подмножество $C$, индуцированное $A_i \cup \{v_i\}$.

\textbf{Утверждение.} Если вершина $v_i$ критическая, то $w(C_i) \ge w(v_i, A_i)$.

\textbf{Доказательство.} Индукцией по количеству критических вершин в порядке их появления.
Для первой очевидно, так как достигается равенство: действительно, все рёбра из неё ведут в другую долю и все рёбра из другой доли ведут в неё, так как она первая.
Переход: пусть верно для критической вершины $v_p$, рассмотрим следующую критическую вершину $v_q$.
Не умаляя общности, пусть $v_p$ находится в правой доли, а $v_q$ --- в левой. 
Тогда распишем, из каких частей состоит $w(C_q)$, чтобы подогнать под предположение индукции:
\[
    w(C_q) = w(C_p) + w(v_q, A_q \cap RIGHT) + w(A_p \cap LEFT, \{v_{p+1}, \dots, v_{q-1}\}) \ge
\]
(просто выкинем по неотрицательности весов рёбер)
\[
     \ge w(C_p) + w(v_q, A_q \cap RIGHT) \ge
\]
(по предположению индукции)
\[
    \ge w(v_p, A_p) + w(v_q, A_q \cap RIGHT) \ge
\]
(по построению алгоритма: так как $v_p$ было взято на $p$-ом шаге и мы брали максимум по $w(v_p, A_p)$, получаем $w(v_p, A_p) \ge w(v_q, A_p)$)
\[
    \ge w(v_q, A_p) + w(v_q, A_q \cap RIGHT) \ge w(v_q, A_q).
\]
Таким образом, $w(C) = w(C_n) \ge w(v_n, A_n) = w(t, V \setminus \{t\})$, так как $t$ критическая.

Последовательность $\{v_n\}$ можно построить за $O(V^2)$, так как каждое ребро добавляется в $\argmax$ ровно один раз, поэтому суммарно всё работает за $O(V^3)$.

\subsection{Дерево Гомори-Ху}
Пусть нам дан неориентированный граф с рёбрами неотрицательного веса и запросы вида $(u, v)$.
В ответ мы хотим выводить минимальный разрез между вершинами $u$ и $v$.
Утверждается, что можно построить дерево на тех же вершинах, такое что минимальный разрез в исходном графе равен минимальному разрезу в дереве.

Пусть $f_{u,v}$ --- стоимость минимального разреза между $u$ и $v$.

\textbf{Лемма 1.} Для любых $u, v, w \in V$ верно $f_{u,v} \ge \min(f_{u,w}, f_{w, v})$.

\textbf{Доказательство.} Рассмотрим минимальный разрез $(X, Y)$ между $u \in X$ и $v \in Y$.
Если $w \in X$, то вот нашли разрез между $w$ и $v$ стоимостью $f_{u,v}$, то есть $f_{w,v} \le f_{u,v}$.
Аналогично в другом случае.

\textbf{Следствие.} Если рассмотреть последовательность вершин $u = w_1, w_2, \dots, w_k = v$, то будет верно $f_{u,v} \ge \min(f_{u,w_2}, f_{w_1,w_3}, \dots, f_{w_{k-1},v})$.
Действительно, применим лемму несколько раз:
\[
    f_{u,v} \ge \min(f_{u, w_2}, f_{w_2, v}) \ge \min(f_{u, w_2}, \min(f_{w_2, w_3}, f_{w_3, v})) \ge \dots
\]

Положим $F := (f_{u,v})$ --- матрица $n \times n$, $G_r$ --- граф с такой матрицей смежности.

\textbf{Утверждение.} Максимальный остов $G_r$ --- искомое дерево.

\textbf{Доказательство.} Рассмотрим две вершины $u$ и $v$ и путь между ними $u = w_1, \dots, w_k = v$.
Тогда $f_{u,v} \ge \min(f_{u,w_1}, \dots, f_{w_{k-1},v})$ по лемме 1.
Обратное неравенство следует из структуры максимального остовного дерева: допустим, что строго больше, чем все рёбра на пути, тогда ребро $(u, v)$ должно было оказаться в остове.

Таким алгоритмом мы можем построить дерево за $O(V^2 \cdot maxFlow)$.
Но из построенного выше остова мы видим, что $f_{u,v}$ может принимать лишь $n - 1$ различное значение --- веса рёбер в максимальном остове.
Поэтому возникает желание как-нибудь понять, между какими парами вершин возникают различные минимальные разрезы, и только для них искать максимальный поток, чтобы получить время работы $O(V \cdot maxFlow)$.

Зафиксируем две вершины $u$ и $v$, пусть $A_u$ --- множество минимального разреза, в котором лежит $u$, $A_v$ --- в котором лежит $v$.

\textbf{Утверждение.} Рассмотрим две произвольные вершины $x, y \in V$. 
Тогда между ними существует минимальный разрез, такой что $A_v$ целиком лежит в одной из долей.

\textbf{Доказательство.} Рассмотрим произвольный разрез $(X \ni x, Y \ni y)$.
Положим $X_u = X \cap A_u$, аналогично $X_v, Y_u, Y_v$.
Не умаляя общности, $v \in X_v$.
Перенесём вершины из $Y_v$ в $X_v$ --- утверждение состоит в том, что разрез от этого хуже не станет.
Изначальная стоимость разреза между $x$ и $y$ --- это $w(X_u, Y_u) + w(X_u, Y_v) + w(X_v, Y_u) + w(X_v, Y_v)$.
Новая стоимость --- $w(X_u, Y_u) + w(X_v, Y_u) + w(Y_u, Y_v)$.
Мы хотим доказать, что $w(X_u, Y_u) + w(X_u, Y_v) + w(X_v, Y_u) + w(X_v, Y_v) \ge w(X_u, Y_u) + w(X_v, Y_u) + w(Y_u, Y_v)$.
Или же, сокращая лишнее, что $w(X_u, Y_v) + w(X_v, Y_v) \ge w(Y_u, Y_v)$.

Чем вообще можно пользоваться при доказательстве? 
Всё, что мы знаем, --- это то, что разрез $u-v$ минимален, то есть стоимость разреза $(X_v, Y_v \cup Y_u \cup X_u)$ не меньше.
На языке математики: $w(X_v, Y_v) + w(X_v, Y_u) + w(X_v, X_u) \ge w(X_u, X_v) + w(X_u, Y_v) + w(Y_u, X_v) + w(Y_u, Y_v)$.
Сокращая, получаем $w(X_v, Y_v) \ge w(Y_u, Y_v) + w(Y_u, X_v)$.
В силу неотрицательности рёбер $w(X_v, Y_v) \ge w(Y_u, Y_v)$ --- остаётся прибавить слева $w(X_u, Y_v)$, и мы получили искомое неравенство.

Данное утверждение даёт нам возможность решать задачу таким образом: изначально у нас есть одна большая мета-вершина $A$, соответствующая всем вершинам исходного графа, далее мы будем разбивать её на мета-вершины поменьше, пока не дойдём до исходных вершин графа, следующим алгоритмом:
\begin{itemize}
    \item Возьмём две вершины $u$, $v$ и найдём между ними максимальный поток.
    \item Выделим минимальный разрез $(X \ni u, Y \ni v)$ и разобьём $A$ на мета-вершины $X$ и $Y$, проведя между ними ребро стоимостью $f_{u,v}$.
    \item Как и в $A$, найдём в $X$ минимальный разрез $X_1 \sqcup X_2 = X$ и проведём между мета-вершинами $X_1$, $X_2$ ребро.
        Если $Y \in X_1$ (как мета-вершина), то перепроводим ребро $(Y, X)$ в $X_1$, иначе --- наоборот.
        И так далее, для $Y$ аналогично.
\end{itemize}

По итогу получается какое-то дерево. Наша цель --- доказать, что оно является искомым (с построенным ранее деревом оно не обязано совпадать, та часть была просто для доказательства существования).

\textbf{Лемма 2.} Пусть $A$ и $B$ --- мета-вершины на каком-то этапе построения дерева, соединённые ребром стоимостью $c$.
Тогда существуют $u \in A$ и $v \in B$, такие что $f_{u,v} = c$.
Главная проблема не в том, что при появлении ребра у него непонятно какая стоимость (это как раз понятно), а в том, что если $c = f_{u, v}$ и мы разрезали $A$, $u$ могла перейти в другую мета-вершину, и свойство перестало выполняться.

\textbf{Доказательство.} По индукции. После первого разреза, очевидно, найдутся.
Переход: пусть мы разрезаем мета-вершину $A$, соединённую с $B$ ребром стоимостью $c$.
По предположению индукции существуют вершины $u \in A$, $v \in B$, такие что $c = f_{u,v}$.
Теперь пусть мы выбрали в $A$ вершины $a_1, a_2$ и сделали по ним минимальный разрез стоимостью $c'$ на $A_1 \sqcup A_2 = A$, не умаляя общности, $B$ соединено с $A_1$.
Тогда у нас есть 2 случая: $u \in A_1$ и $u \in A_2$.

\begin{figure}[ht]
    \centering
    \incfig{gomory}{0.5\linewidth}
\end{figure}

Во-первых, в обоих случаях $c' = f_{a_1, a_2}$ по построению.
Теперь разбираем случаи для $c$: если $u \in A_1$, то пара $(u, v)$ всё ещё прекрасно подходит.
При $u \in A_2$: по лемме 1 $f_{a_1, v} \ge \min(f_{a_1, a_2}, f_{a_2,u}, f_{u,v})$.
Уберём лишние слагаемые справа.
Заметим, что $f_{a_2, u}$ тут совсем не при чём: мы можем делать стоимости рёбер в $A_2$ сколь угодно большими, но $f_{a_1, v}$ от этого не изменится.
Поэтому $f_{a_1, v} \ge \min(c, c')$.
Но $c'$ --- это, в частности, разрез между $u$ и $v$, поэтому $c' \ge c$.
Получаем $f_{a_1, v} \ge f_{u,v}$.
Противоположное неравенство аналогично: $c$ --- это разрез между $a_1$ и $v$, поэтому $f_{u,v} \le f_{a_1, v}$.

Таким образом, мы нашли две подходящие вершины $a_1 \in A_1$ и $v \in B$, такие что $c = f_{a_1, v}$.

\textbf{Теорема.} Для всех пар вершин $u$, $v$, на пути между которыми в построенном дереве идут рёбра стоимостями $c_1, \dots, c_k$, выполнено $f_{u,v} = \min(c_1, \dots, c_k)$.

\textbf{Доказательство.} Докажем два неравенства.

$\le$: каждое ребро на пути --- это какой-то разрез между $u$ и $v$, так что $f_{u,v}$ не больше каждого из них.

$\ge$. Пусть $u = w_1, w_2, \dots, w_{k+1} = v$ --- путь между $u$ и $v$ в дереве.
По лемме 2 получаем, что $c_1 = f_{w_1, w_2}$, $c_2 = f_{w_2, w_3}$, $\dots$, $c_k = f_{w_k, w_{k+1}}$.
Остаётся применить лемму 1.

\textbf{Следствие.} Построенное дерево --- дерево Гомори-Ху.

\section{Строки}
\textbf{Соглашения.} Индексация может быть как и с нуля, так и с единицы, пустая строка является подстрокой всех строк.

\subsection{Поиск подстроки в строке}
Хотим найти вхождение строки $T$ в строке $S$. Алгоритм за $O(|S| \cdot |T|)$ очевиден, посмотрим на другие варианты.

\subsubsection{Префикс-функция}
Пусть $p$ --- префикс-функция строки. Все доказательства в этом пункте делаются внимательным рассмотрением рисунка.
На этот алгоритм можно смотреть, как на метод двух указателей.

Лемма 1: $p[i + 1] \le p[i] + 1$, очевидно из рисунка.

Лемма 2: если $p[i + 1] < p[i] + 1$, то $p[i + 1] \le p[p[i]] + 1$.
В очередной раз можно нарисовать рисунок и заметить, что можно рассмотреть предыдущий префикс и сравнить с ним.

При помощи префикс-функции можно прийти к \textit{алгоритму Кнута} \textit{-Морриса-Пратта}: насчитаем префикс-функцию на строке \verb+T$S+ и посмотрим на её значения.
Интересный факт: размер массива префикс-функции можно сделать $|T|$, так как значения префикс-функции не превосходят $|T|$.

Более того, заметим, что при подсчёте префикс функции нас интересует только префикс-функция на предыдущей позиции и текущий символ.
Поэтому мы можем ввести функцию $go(i, c)$ --- сделать следующий шаг, зная, что префикс-функция --- $i$, а текущий символ --- $c$, и получить автомат префикс-функции.

\subsubsection{Z-функция}
Тривиально.

\subsubsection{Хэши}
Очевидно.

\subsection{Палиндромы}
\subsubsection{Алгоритм Манакера}
Вставим между соседними символами строки $S$ какие-нибудь символы. Теперь нам достаточно найти все палиндромы нечётной длины.
Посчитаем массив $p$ --- максимальную длину палиндрома с центром в данной позиции.

Можно вычислить слева направо, пользуясь фактом, что максимальная длина палиндрома с центром в данном символе --- хотя бы длина для симметричной позиции относительно центра палиндрома, покрывающего нас.

\textbf{Задача.} (О тандемном повторе) Дана строка, найти подстроку наибольшей длины, являющуюся конкатенацией двух строк.
Будем решать через разделяй и властвуй. Зафиксируем точку разбиения, то есть слева и справа одинаковые строки.
При разделении будем просто находить Z-функцию от развёрнутой левой части и правой части.

\textbf{Определение.} Строка $T$ $l$-\textit{периодическая}, если $T_i = T_{l+i}$ для всех $i$.

Тогда предыдущая задача сводится к нахождению $l$-периодической строки длины хотя бы $2l$.

\subsubsection{Дерево палиндромов}
Дана строка $S$ и нам поступают запросы вида ``входит ли строка $P$ --- палиндром --- как подстрока в $S$?``.

\textbf{Утверждение.} В строке $S$ содержится не более $|S|$ различных палиндромов.

\textbf{Доказательство.} Индукцией по построению $S$. Припишем символ в конец, теперь у нас могло появиться не более одного палиндрома, так как саммый длинный, может, не встречался, а остальные уже встречались, как часть самого длинного палиндрома.

Выпишем все подпалиндромы для данной строки. Теперь построим два бора на правых половинах этих палиндромов (чётных и нечётных).

\textbf{Определение.} Дерево палиндромов --- построенный бор. Его размер линеен, так как каждая вершина задаёт палиндром.

Теперь будем строить дерево, добавляя в строку по одному символу, находя самый длинный палиндром, проходящий через новый символ и добавляя палиндром в дерево при необходимости.
Находить самый длинный палиндром нетрудно: новый самый длинный палиндром --- это палиндром, заканчивающийся в предыдущем символе с новым символом.

Это, конечно, можно сделать хэшами, но лучше через суффиксные ссылки. Для этого введём следующие понятия: $\pal(v)$ --- палиндром, соответствующий вершине $v$, $\suff(v)$ --- множество всех $u$, таких что $\pal(u)$ --- собственный префикс $\pal(v)$ и длина $\pal(u)$ максимальна, $\len(v) = |\pal(v)|$.
Будем считать $\len(root_{odd}) = -1$ и $\len(root_{even}) = 0$ и проведём между корнями суффиксную ссылку, то есть $\suff(root_{even}) = root_{odd}$.

Будем находить тремя указателями: один указатель на конец, второй --- на начало текущего самого длинного палиндрома, заканчивающегося в последнем символе, третий --- на суффиксную ссылку, то есть на второй по длине самый большой суффикс.

\textbf{Задача.} Даны две строки $S$ и $T$, нужно поддерживать для каждой позиции $T$ максимальную длину суффикса $T[0..i]$, являющегося палиндромом и встречающегося в $S$.
Можно построить дерево палиндромов на $S$ и, поддерживая суффиксные ссылки и в $S$, и в $T$, проверять вхождения.
Другой вариант: построить деревья палиндромов для двух строк и запустить параллельный поиск в глубину.

\subsection{Поиск подстроки в строке с $O(1)$ дополнительной памяти}
По большей части этот параграф написан по авторской статье ``Z. Galil, J.I. Seiferas: Time-space-optimal string matching``, а не по лекциям.
\subsubsection{Основные понятия}
Зафиксируем константу $k = 4$.

\textbf{Определение.} Строка $p$-периодична, если любые два символа на расстоянии $p$ равны.

\textbf{Определение.} $\reach_S(p)$ --- максимальная длина $p$-периодичного префикса строки $S$.

\textbf{Определение.} Базовая строка --- строка, не представимая в виде конкатенации нескольких одинаковых строк.

\textbf{Определение.} $T$ --- префиксный период $S$, если $T^k$ --- префикс $S$ и $T$ базовая.

\textbf{Определение.} $\shift_S(p) = p - \pi_S[p]$. Иными словами, минимальное $l$, такое что префикс длины $p$ $l$-периодичен.

\sloppy \textbf{Лемма 0.} (О периодичности) Если строка $S$ $a$-периодична и $b$-периодична, её длина --- хотя бы $a + b$, то она $gcd(a, b)$-периодична.

\textbf{Доказательство.} Не умаляя общности, $a > b$ (случай $a = b$ остаётся в качестве упражнения).
Докажем, что строка $(a - b)$-периодична.
Рассмотрим $i$-ый символ, где $i + a \le |s|$: он равен $(i + a)$-ому, а $(i + a)$-ый равен $(i + a - b)$-ому символу.
Если же $i + a > |S|$ и $i + a - b \le |S|$, то пройдём в порядке $i \to i - b \to i + a - b$ (засчёт $a + b \ge |S|$ можно гарантировать, что $i - b > 0$).
Следовательно, $i$-ый символ равен $(i + a - b)$-ому, и строка $(a - b)$-периодична.
Остаётся применить алгоритм Евклида.

\textbf{Замечание.} Утверждается, что достаточно просить, что длина --- хотя бы $a + b - gcd(a, b)$, но это всё равно нигде не поможет.

\textbf{Лемма 1.} Если $\shift_S(q) \le \frac{q}{k}$, то $S[1..\shift_S(q)]$ --- префиксный период.

\textbf{Доказательство.} По определению шифта $S[1..q]$ имеет период $\shift_S(q)$, и, так как $\shift_S(q) \le \frac{q}{k}$, $S[1..\shift_S(q)]^k$ является префиксом $S[1..q]$.
Остаётся доказать, что $S[1..\shift_S(q)]$ базовая.
От противного, допустим, что $S[1..\shift_S(q)] = T^l$ для $l > 1$.
Но тогда строка $S[1..q]$ будет $|T|$-периодична --- противоречие, так как $|T| < \shift_S(q)$.

\textbf{Лемма 2.} Если $S[1..l]$ --- префиксный период $S$, то для любого $q$ верно
\[
    l = \shift_S(q) \le \frac{q}{k} \iff kl \le q \le \reach_S(l).
\]

\textbf{Доказательство.} $\Rightarrow$: первое неравенство совсем очевидно, докажем второе от противного.
Тогда длина любого $l$-периодичного префикса строки $S$ строго меньше $q$.
Но по определению шифта префикс длины $q$ должен быть $l$-периодичен --- противоречие.

$\Leftarrow$. Во-первых, префикс длины $\reach_S(l) \ge q$ $l$-периодичен, поэтому $\shift_S(q) \le l$.
Допустим, что $\shift_S(q) < l$. Тогда у префикса длины $kl$ есть два периода: $l$ и $\shift_S(q)$.
По лемме 0 он $gcd$-периодичен, следовательно, префикс длины $l$ $gcd$-периодичен и не является базовым.

\subsubsection{Теорема о декомпозиции}
Для любой строки $p$ её можно представить в виде $p = uv$, где у $v$ не более одного префиксного периода и $|u| = O(\shift_v(|v|))$.
Будет доказано ниже.

\textbf{Утверждение.} Пусть у строки $s = T^k$, где $T$ --- базовая, есть префиксный период длины $p_1$ и базовый префикс длины $p_2$, причём $p_2 > p_1$ и $\reach(p_2) \ge 2p_2$.
Тогда $p_2 > (k-1)p_1$.

\textbf{Доказательство.} От противного: пусть $p_2 \le (k-1)p_1$.
Тогда по лемме о периодичности строка $gcd(p_1, p_2)$-периодична, то есть строка $p_2$ $gcd(p_1,p_2)$-периодична, то есть она не базовая --- противоречие.

\textbf{Лемма 3.} Пусть $w$ --- базовая строка. Тогда существует разбиение $w = w_1w_2$, такое что для любой строки $w'$ строка $w_2 w^{k-1}w'$ не имеет префиксный период, меньший $|w|$.

\textbf{Доказательство.} Рассмотрим произвольное разбиение $w = w_1 w_2$.
\sloppy Во-первых, заметим, что строка $w_2 w^{k-1}$ $|w|$-периодична по определению ($w_2 w^{k-1} = w_2w_1w_2w_1 \dots$), причём строка $w_2w_1$ базовая, как циклический сдвиг базовой.
Допустим, что нашёлся префиксный период строки $w_2 w^{k-1} w'$ длины $p_1 < |w|$, такой что в $w_2 w^{k-1}$ не влезло $k$ его копий.
Вместе с тем, что у неё есть базовый префикс $w_2 w_1$, к ней можно применить утверждение выше и получить $p_1 < \frac{|w|}{k-1}$. Тогда
\[
    kp_1 < |w| \frac{k}{k-1} < |w|(k - 1).
\]
То есть префикс длины $p_1$, повторённый $k$ раз, влезает в $w_1 w^{k-1}$ --- противоречие.
Следовательно, вне зависимости от $w'$ префикс длины $p_1$ будет префиксным периодом $w_2 w^{k-1} w'$.
Поэтому мы можем зафиксировать $w' = w^\infty$ и дальше доказывать для строки $S := w_2 w^{\infty}$.

Теперь к самому построению разложения.
Раз мы не хотим иметь префиксный период меньше $|w|$, будем находить минимальную по длине строку $z$, такую что $z^k$ --- префикс оставшейся строки, и отпиливать $z$, если $|z| < |w|$.
Теперь докажем, что рано или поздно это прекратится.

Пусть мы отпиливали строки $z_1, z_2, \dots$.
Утверждается, что их длины не убывают и каждая строка --- префикс следующей.
Пусть мы отпилили $z_i$, тогда дальше ещё осталось $k - 1$ копий $z_i$, то есть $z_{i+1}$ --- это либо префикс $z_i$, либо наоборот.
Допустим, что $|z_{i+1}| < |z_i|$, тогда по лемме 0 строка $z_i^k$ $gcd$-периодична, что даёт противоречие с минимальностью её длины.
Если этот процесс остановился, то у нас осталась строка $w_4www\dots$ ($w_4$ --- суффикс $w$), тогда берём разбиение $w = w_3w_4$, где $w_3$ --- оставшийся префикс.
Иначе процесс стабилизировался на длине $m < |w|$, но тогда у оставшейся строки есть период $m$ и $m < |w|$ --- это значит, что по лемме 0 она $gcd$-периодична и строка $w$ не базовая.
Следовательно, процесс обязательно остановится.

\textbf{Замечание 1.} $|z_{i+1}| \ge (k - 2)|z_i|$. 
От противного, тогда на момент удаления $|z_{i+1}| + |z_i| \le (k - 1)|z_i| = |z_i^{k-1}|$.
Вспомним, что на момент удаления $z_{i+1}$ она была префиксом строки $z_i^{k-1}$, то есть, применяя к префиксу $z_i^{k-1}$ длины $|z_{i+1}| + |z_i|$ лемму 0, получаем противоречие с минимальностью $z_{i+1}$.

\textbf{Замечание 2.} $z_i^{k-2}$ является префиксом строки, полученной после удаления $z_i$ --- это понятно.
Но по замечанию 1 она также является префиксом $z_{i+1}$ и префиксом $z_{i+1}^{k-2}$, а она, в свою очередь, является префиксом строки, полученной после удаления $z_{i+1}$.
Продолжая рассуждение, получаем, что $z_i^{k-2}$ будет префиксом \textit{всех} последующих строк.

\textbf{Замечание 3.} Этот процесс удалит менее $|w|$ символов.
Допустим, что мы удалили $p > |w|$ символов.
Посмотрим на позицию $p - |w|$: если мы удалили строку $z$ с началом в этой позиции, то мы и сейчас можем её удалить в силу периодичности строки $S$.
Следовательно, существует строка $z$, которая началась до позиции $p - |w|$, закончилась --- после, и которую мы удалили.

\begin{figure}[ht]
    \centering
    \incfig{galil1}{0.5\linewidth}
\end{figure}

Вспоминая замечание 2, получаем, что $z^{k-2}$ --- префикс оставшейся строки, начиная с позиции $p + 1$.
И в силу периодичности $z^{k-2}$ --- префикс строки, начиная с позиции $p - |w| + 1$.

\begin{figure}[ht]
    \centering
    \incfig{galil2}{0.5\linewidth}
\end{figure}

Следовательно, строка $z$ имеет нетривиальный период --- противоречие с минимальностью.

Таким образом, это можно даже написать за квадрат и $O(1)$ дополнительной памяти.

\textbf{Доказательство.} (Теоремы о композиции)
Будем повторять следующие действия, пока у строки $R$ есть хотя бы два префиксных периода $p_1$ и $p_2$:
\begin{itemize}
    \item Найдём $i \le p_2$, такой что $R[i..|R|]$ не имеет префиксный период короче $p_2$ (по лемме 3).
    \item Присвоим $R \leftarrow R[i..|R|]$.
\end{itemize}
Теперь положим $v = R$ и $u$ --- удалённый префикс.
То, что у $v$ не более одного префиксного периода, следует из условия цикла.
Докажем, что $|u| = O(\shift_v(|v|))$.

Рассмотрим периоды, которые возникали: пусть $p_{1,1}, \dots, p_{1,l}$ --- первые периоды, $p_{2,1}, \dots, p_{2,l}$ --- вторые.
Тогда для всех $i$ $p_{1,i} \cdot (k - 1) < p_{2,i}$ и $p_{2,i} \le p_{1,i+1}$.
Мы отпилили не более $p_{2,1} + p_{2,2} + \dots + p_{2,l} \le p_{2,l} \left( \dots + \frac{1}{(k-1)^2} + \frac{1}{k-1} + 1 \right) = \Theta(p_{2,l})$.

Так как на последнем шаге мы отпилили префикс длины $p_{2,l}$, являющийся префиксным периодом, мы знаем, что $|v| \ge p_{2,l}^{k-1}$.
Теперь если $\shift_v(|v|) < p_{2,l}$, то традиционно применяем лемму 0 к префиксу длины $p_{2,l}^{k-1}$ и получаем противоречие с базовостью префикса длины $p_{2,l}$.
Следовательно, $|u| = O(p_{2,l})$ и $\shift_v(|v|) \ge p_{2,l}$.

\subsubsection{Принцип работы алгоритма}
Пусть мы находим вхождения строки $R$ в строку $S$.
Глобально, алгоритм работает по следующей схеме: пусть $p$ --- текущая позиция в строке $S$, $q$ --- длина префикса $R$, про который мы точно знаем, что $S[p..p + q) = R[0..q)$, $f$ --- магическая функция, которая считает, куда надо прыгать, в которой и заключается весь алгоритм:
\begin{algorithm}[H]
    \DontPrintSemicolon
    $(p, q) \leftarrow (1, 0)$ \;

    \While {$p \le |S|$} {
        \While {$S_{p+q} = R_{q + 1}$} {
            $q \leftarrow q + 1$ \;
        }
        \If {$q = |R|$} {
            Нашли вхождение $S[p..p+q) = R$ \;
        }
        $(p, q) \leftarrow f(p, q)$ \;
    }
\end{algorithm}

Например, если взять $f(p, q) = (p + 1, 0)$, то мы получим наивный поиск за $O(|S| \cdot |R|)$.
Но теперь к тому, почему теорема о декомпозиции так важна.
Заметим, что если бы нам везло и при подсчёте $f$ всегда бы случалось так, что $\shift_R(q) > \frac{q}{k}$, то мы бы могли просто брать $f(p, q) = (p + \max(1, \lceil q / k \rceil), 0)$, получая линейное время работы.
Действительно, шифт --- это по определению минимальный прыжок, который нужно сделать, чтобы был смысл в поиске вхождения.

Итак, применим теорему о декомпозиции: $R = uv$.
Если у $v$ нет префиксных периодов, то $\shift_v(|v|) > \frac{q}{k}$ и мы можем применять переход выше.
Но если есть префиксный период длины $p_1$, то переход становится сложнее:
\[
    f(p, q) =
    \begin{cases}
        (p + p_1, q - p_1), & \text{если $kp_1 \le q \le \reach_v(p_1)$}, \\
        (p + \max(1, \lceil q / k \rceil), 0), & \text{иначе}.
    \end{cases}
\]
Откуда это берётся: заметим, что условия очень похожи на лемму 2.
Действительно, если не выполнены неравенства, то $\shift_v(q) > \frac{q}{k}$, и мы можем смело прыгать дальше.
А если выполнены, то в силу базовости префикса длины $p_1$ мы тоже можем прыгать сразу на него (иначе, не поверите, лемма 0).
Таким образом, нам остаётся построить декомпозицию и найти $p_1$ с $\reach_v(p_1)$.

\subsubsection{Быстрое построение декомпозиции}
На самом деле, процедуру из доказательства теоремы можно эффективно реализовать.

\textbf{Нахождение самого короткого префиксного периода}

Для начала нужно научиться находить самый короткий префиксный период, чтобы применять лемму 3.
Для этого будем использовать алгоритм выше на строке $S$ и ей же самой, начиная с $p = 2, q = 0$. 
Понятно, что вхождение мы не найдём, нас интересует другое: если оказалось, что $p + q = i$, и такое значение $i$ мы встретили впервые, то $\shift_S(i) = p - 1$.

Докажем, что $\shift_S(i) \le p - 1$ для всех позиций $p$, где встретилось $i$.
Действительно, если $S[p..p + q)$ совпадает с $S[1..q]$, то строка $S[1..i]$, как минимум, $(p - 1)$-периодична.
Теперь неравенство в другую сторону следует из того, что мы встретили $i$ впервые, то есть $p$ минимально.

Что нам теперь с этим делать?
Заметим, что если $\shift_S(i) \le \frac{i}{k}$, то мы нашли какой-то префиксный период по лемме 1, а если нет, то можно прыгать в $(p + \max(1, \lceil q / k \rceil), 0)$.
Но найдём ли мы префиксный период минимальной длины?
Пусть $p_1$ --- длина минимального префиксного периода.
Тогда по рассуждениям выше мы не могли перепрыгнуть позицией $p$ через $p_1 + 1$ в силу базовости (в этом случае перед этим прыжком $q \ge k p_1$ и $p \in (1, p_1 + 1)$, так что опять лемма 0), а при попадании в неё вхождение точно найдётся.

Время работы: если не нашли, то мы просто пройдём всю строку за $O(|S|)$, а если нашли, то остановимся в позиции $p_1$, то есть $O(p_1)$.

\textbf{Нахождение префиксного периода меньше данного}

Пусть мы хотим найти префиксный период длины менее $p_2$.
Аналогично предыдущему мы можем искать минимальный.
Если нашёлся $p_1 < p_2$, то время работы будет $O(p_1)$.
А если не нашёлся, то найдётся префиксный период длины $p_2$, и будет $O(p_2)$.

\textbf{Нахождение второго по длине префиксного периода}

Принцип тот же самый. Для начала найдём самый короткий префиксный период $p_1$ и посчитаем $\reach_S(p_1)$ за $O(\reach_S(p_1))$.
Теперь, как и в самом алгоритме, мы можем взять функцию перехода
\[
    f(p, q) =
    \begin{cases}
        (p + p_1, q - p_1), & \text{если $kp_1 \le q \le \reach_S(p_1)$}, \\
        (p + \max(1, \lceil q / k \rceil), 0), & \text{иначе}.
    \end{cases}
\]
Не совсем очевидно, почему первый переход легален в случае, когда у нас потенциально несколько префиксных периодов: могло произойти такое, что мы перепрыгнули через второй префиксный период $p_2$.
Пусть мы так перепрыгнули, стартуя из $(p, q)$.
Тогда $\shift_S(q) \le \frac{q}{k}$, иначе мы бы пошли вторым переходом, который легален.
Более того, $\shift_S(q) \ne p_1$ означал бы, что мы нашли уже здесь второй префиксный период.
Следовательно, $\shift_S(q) = p_1$, а на $p_1$ прыгать можно по определению шифта.

За какое время мы найдём $p_2$ (или поймём, что его нет)?
Нахождение $\reach_S(p_1)$ может вызывать сомнения, но заметим, что если $p_2 < \reach_S(p_1) - p_1$, то у нас опять противоречие по лемме 0.
Следовательно, $\reach_S(p_1) = O(p_2)$, а дальше ничего нового: как и в поиске минимального префиксного периода $O(p_2)$, если нашли, $O(|S|)$, если нет.

\textbf{Собираем всё вместе}

Итак, оценим, за сколько мы умеем находить разбиение из леммы 3.
На нахождение минимального префиксного периода длины $p_1$ уходит $O(p_1)$, после чего мы отпиливаем $p_1$ символов.
Следовательно, здесь $O(|S_1|)$, где $S = S_1 S_2$ --- разбиение.
В теореме о декомпозиции мы ещё ищем второй префиксный период $p_2$, так что, пользуясь тем, что $|S_1| \le p_2$, получаем время работы на одну итерацию $O(|S_1|) + O(p_2) = O(p_2)$ (либо $O(|S|)$, и это последняя итерация).

Остаётся понять, за сколько суммарно это будет работать.
Пусть $p_2$ и $p_2'$ --- длины двух последовательных вторых префиксных периодов, которые мы нашли.
Вспоминим, что между нахождением $p_2$ и $p_2'$ мы удалили не более $p_2$ символов, то есть оставшаяся строка имеет $p_2$-периодичный префикс длины хотя бы $(k - 1) p_2$.
Тогда если $p_2' \le p_2 (k - 2)$, то по лемме 0 получаем противоречие с базовостью.
Следовательно, каждый следующий $p_2$ хотя бы в 2 раза больше предыдущего, и время работы всего цикла --- $O(|S| (1 + \frac{1}{2} + \frac{1}{4} + \dots)) = O(|S|)$.

Это нам позволяет построить декомпозицию строки $R$ за $O(|R|)$, после чего найти все вхождения за $O(|S|)$.

\subsection{Суффиксный автомат}
Для ответа на запросы принадлежности подстроки строке можно построить бор на суффиксах за квадрат, но можно лучше.

\textbf{Определение.} Суффиксный автомат $\DAWG(s)$ --- это минимальный ДКА, языком которого является множество суффиксов строки $s$.

\textbf{Определение.} Пусть $x$ --- подстрока $S$.
Тогда правым контекстом $R_S(x)$ называется $\{y~|~\text{$xy$ --- суффикс $s$}\}$.

\textbf{Определение.} $x_1 \sim x_2$, если $R_S(x_1) = R_S(x_2)$.

\textbf{Утверждение.} Пусть $x_1 \sim x_2$ и $|x_1| > |x_2|$. Тогда $x_2$ --- суффикс $x_1$.
Посмотрим на строку и на определения, очевидно.
Более того, если $x$ --- суффикс $x_1$, такой что $|x_1| > |x| > |x_2|$, то $R_S(x) = R_S(x_1) = R_S(x_2)$.

\textbf{Определение.} Пусть $x$ --- подстрока $S$. Тогда
\begin{itemize}
    \item $[x]_S$ --- класс эквивалентности $x$ по $S$.
    \item $\longest([x]_S)$ --- самая длинная строка в $[x]_S$.
    \item $\len([x]_S) = |\longest([x]_S)|$.
\end{itemize}

\textbf{Утверждение.} Если нам даны longest-ы, то класс эквивалентности --- это longest и его суффиксы, пока не упрёмся в longest.
Но не могло ли произойти так, что мы упёрлись в строку из другого класса эквивалентности, не являющуюся longest-ом?
Нет, от противного: пусть есть строка $y$ и символы $a$ и $b$, такие что $ay \not\sim by$, но $y \sim by$.
Так как $R_S(ay) \subset R_S(y)$ и $R_S(y) = R_S(by)$, получаем $R_S(ay) \subset R_S(by)$.
Аналогично в обратную сторону и выходит $ay \sim by$.

\textbf{Лемма.} Пусть $x$ --- подстрока $S$. Тогда $x = \longest([x]_S)$ тогда и только тогда, когда ($\exists a \ne b:$ $ax, bx$ --- подстроки $S$) или ($x$ --- префикс $S$).

\textbf{Определение.} Суффиксная ссылка --- 
\[
    \suff([x]_S) = \{[y]_S~|~\text{$y$ --- суффикс $x$, $[x]_S \ne [y]_S$, $|y| \to \max$}\}.
\]
Определение написано, как множество, но $y$ определяется однозначно засчёт максимизации длины.
Не определена для пустого слова и только для него.

\textbf{Определение.} Дерево суффиксных ссылок --- дерево, в котором ребро из родителя в ребёнка идёт тогда и только тогда, когда суффиксная ссылка из ребёнка ведёт в родителя.

\textbf{Замечание.} Количество детей у строки в суффиксном дереве --- количество способов приписать слева символ так, чтобы она осталась подстрокой.

\textbf{Утверждение.} В дереве суффиксных ссылок есть не более $|S| + 1$ вершин с не более, чем 1 ребёнком (просто все префиксы строки).
Более того, не более $|S|$, если строка не имеет вид $a^n$.

\textbf{Утверждение.} (Глобально про деревья) Пусть у дерева $p$ листов и $q$ вершин с одним ребёнком.
Тогда у него не более $2p + q - 1$ вершин.
Можно смотреть на это так: сначала есть $p$ листьев, потом при добавлении каждой вершины мы либо уменьшаем $q$, либо объединяем хотя бы две вершины в одну.

\textbf{Теорема.} Пусть $|S| \ge 2$. Тогда $\DAWG(S)$ содержит не более $2|S| - 1$ вершин, причём если $|S| \ge 3$, то ровно $2|S| - 1$ тогда и только тогда, когда $S = ab^{n-1}$.
Следует из двух предыдущих утверждений.

\textbf{Теорема.} Если $|S| \ge 3$, то в $\DAWG(S)$ не более $3|S| - 4$ рёбер.

\textbf{Доказательство.} У автомата есть конечная вершина $[S]_S$, запустим из неё DFS по обратным рёбрам и построим дерево.
Тогда в дереве не более $2|S| - 2$ рёбер.
Но мы живём в ориентированном графе, поэтому остались ещё дополнительные рёбра.
Каждому такому ребру можно сопоставить путь, который как-то ходит по автомату, проходит по этому ребру и потом идёт строго по дереву.
Заметим, что строка, полученная проходом по этому пути, --- суффикс $S$, так как она эквивалентна $[S]_S$.
Более того, каждому суффиксу мы сопоставили не более одного ребра, так как автомат детерминированный, то есть путь по строке восстанавливается однозначно, ребро по пути --- тоже, как последнее ребро не в дереве DFS.
Следовательно, таких рёбер не более $|S| - 1$: вычли два, ибо путь суффикса длины $|S|$ состоит полностью из рёбер дерева DFS, пустой суффикс не берём.
Получили $3|S| - 3$. Теперь вспомним, что ровно $2|S| - 2$ рёбер DFS-а может быть ровно в одном случае (описан в предыдущей теореме).
Можно проверить, что в нём не наберётся достаточно рёбер, так что $3|S| - 3$ не достигается.

\subsubsection{Алгоритм построения}
Будем добавлять символы в конец, обновляя автомат, чтобы он содержал новые суффиксы.
Рассмотрим, как автомат меняется при переходе $S \to Sc$.

\textbf{Утверждение.} $[Sc]_{Sc}$ --- множество всех суффисов $Sc$, не входящих в $S$, как подстроки.

\textbf{Теорема.} Пусть $x = \longest([x]_{Sc})$. Тогда верно одно из следующих утверждений:
\begin{itemize}
    \item $x = \longest([x]_S)$.
    \item $x = Sc$.
    \item $x$ --- суффикс $Sc$ и перед всеми вхождениями $x$ в $S$ был один и тот же символ.
        Причём это максимальный такой суффикс: суффиксы длины меньше будут входить в самый длинный, и перед их вхождениями не появятся разные буквы.
        В частности, это максимальный суффикс $Sc$, являющийся подстрокой $S$, возможно, равный пустому слову.
\end{itemize}

Таким образом, можно брать вершину $[S]$, идти по суффиксным ссылкам, пока нет перехода по символу $c$, и добавлять переход по символу $c$ в состояние $[Sc]$.
Так как суммарно рёбер в автомате всегда мало, это работает быстро.
Пусть $S_0$ --- максимальный суффикс $Sc$, входящий в $S$, как подстрока.

Если мы по суффиксным ссылкам пришли в пустое слово, проведём в него суффиксную ссылку из $[Sc]$ и завершимся --- это происходит, если $c$ ещё не встречался в $S$.
Пусть мы дошли до вершины $p$, из которой есть переход по символу $c$.
Утверждение: по символу $c$ ребро идёт ровно в $[S_0]_S$, следует из определения $S_0$.

Теперь нужно проверить, является ли $S_0$ longest-ом в $[S_0]_S$.
Если это так, то $\len(p) + 1 = \len([S_0]_S)$, и нам повезло.
Иначе $S_0c$ станет longest-ом, и состояние $[S_0]_S$ придётся раздвоить и добавить между ними переход по $c$.
Остаётся разобраться с переходами в $[S_0]_S$. Но тут достаточно дальше пройти по суффиксным ссылкам из $p$, пока есть переход в $[S_0]_S$ по $c$, и перенаправить ребро в новую вершину.

Линейность построения всё ещё не доказана, так как мы переподвешиваем рёбра при клонировании вершины.
Доказательство будет добавлено в скором времени™.

\subsubsection{Применение}
\textbf{Задача 0.} Проверить, входит ли подстрока в строку.

\textbf{Задача 1.} Посчитать количество вхождений подстроки в строку.
Достаточно посчитать динамику на автомате, как на ориентированном ациклическом графе.

\textbf{Задача 2.} Найти размер класса эквивалентности вершины $q$. Ответ: $\len(q) - \len(\suff(q))$.

\textbf{Задача 3.} Алиса и Боб играют в следующую игру: дана строка $S$ и её подстрока $p$.
Игроки по очереди дописывают символ в конец строки $p$.
Проигрывает тот, кто дописал символ, после которого $p$ перестала быть подстрокой $S$.

В таком варианте можно вновь написать динамику на DAG-е.
Есть усложнённый вариант: дана $S$, нужно вывести $k$-ую в лексикографическом порядке стартовую подстроку $p$, с которой Алиса выигрывает.
Напишем ту же динамику, теперь в каждой вершине посчитаем, сколько выигрышных подстрок достижимы из неё.
Обойдём автомат, идя каждый в наименьший лексикографически символ и найдём порядковую статистику классическим способом.

Теперь то же самое, но в случае, если мы дописываем символы в начало.
Для начала научимся решать эту задачу для longest-ов: приписывание символа в начало --- это проход по обратной суффиксной ссылке.
Теперь насчитываем динамику, переходя по ним.
Есть оговорка, что при приписывании символа мы могли попасть не в longest, но из вершин, не являющихся longest, ход существует ровно один по определению, так что нужно смотреть на разность длин.
Теперь для поиска $k$-ой в лексикографическом порядке строки можно заметить, что для определения выигрышности подстроки нужно знать выигрышность longest-а и чётность её длины.
Поэтому теперь можно насчитывать ту же динамику, но теперь нужно дополнительно поддерживать чётность длины строки, по которой мы пришли в данное состояние.

\subsection{Суффиксное дерево}
Вновь возвращаемся к задаче поиска подстроки в строке.
Рассмотрим бор на всех подстроках. Заметим, что в нём мало развилок, поэтому можно вместо путей между развилками хранить только одно ребро из полуинтервала, задающего подстроку, которая раньше была в этом пути.

\textbf{Определение.} Полученное дерево называется \textit{сжатым суффиксным бором} или \textit{суффиксным деревом}.

Заметим, что в этом дереве $O(|S|)$ вершин, так как развилок не больше, чем суффиксов строки.
Более того, если внимательно посмотреть на процесс добавления каждого суффикса по-одному, то можно заметить, что каждый раз добавляется не более двух вершин (разрезаем ребро, вставляем вершину посередине и проводим ребро из новой вершины в ещё одну новую) и не более двух рёбер (то же самое).
Можно привести пример, когда эта оценка достигается: допишем в конец символ, который до этого не встречался, к строке вида $a^n$.

\subsubsection{Построение}
Суффиксное дерево можно построить многими халявными способами: взять суффиксный автомат и пройти по нему DFS-ом, взять суффиксный массив и LCP и др.
Но у всех этих решений есть один маленький недостаток: они работают в оффлайне.
Мы же хотим уметь добавлять символ в конец строки и перестраивать суффиксное дерево, сохраняя корректность.

Очевидный алгоритм: будем увеличивать длины всех полуинтервалов на рёбрах и сдвигать указатели, соответствующие суффиксам.
В общем, просто обновим все вершины за линию.

Оптимизация 1: если ребро заканчивается в конце слова, то будем писать на ребре полуинтервал с правым концом в $+\infty$ и не обновлять его при последующих добавлениях символов.

\textbf{Лемма 1.} Подстрока в суффиксном дереве заканчивается в листе тогда и только тогда, когда она является суффиксом, и это единственное её вхождение.

\textbf{Доказательство.} $\Rightarrow$. Действительно, пусть вхождение строки $x$ заканчивается в листе.
Если она не является суффиксом, то в боре есть подстрока $xc$, где $c$ --- символ, то есть у вхождения строки $x$ должен быть потомок с символом $c$.
Если вхождение не единственно, то другое вхождение не будет суффиксом, аналогично должен быть потомок.

$\Leftarrow$. Опять же, если есть потомок, то у текущей строки есть вхождение не в виде суффикса.

\textbf{Следствие.} Если пронумеровать суффиксы слева направо, то сначала несколько (хотя бы один --- вся строка) суффиксов заканчиваются в листах, а потом ни один не заканчивается в листе.
Следует из того, что суффиксы вложены друг в друга.

\textbf{Определение.} FirstNotLeaf (FNL) --- минимальный номер суффикса, не заканчивающегося в листе.

Оптимизация 2: не будем поддерживать указатели на все суффиксы и двигать их после каждого добавления символа, а оставим только указатель на FNL.

\textbf{Утверждение.} Если при добавлении символа $c$ обнаружилось, что из FNL есть переход по символу $c$ и ничего добавлять не нужно, то это верно и для всех остальных суффиксов.

\textbf{Доказательство.} Для суффиксов с меньшими номерами совсем халява --- по оптимизации 1 ничего не нужно делать.
А для суффиксов с бóльшими номерами замечаем, что они вложены в FNL, поэтому из них переход тоже заведомо есть.

Таким образом, если переход есть, то мы двигаем FNL, и добавлять ничего не нужно.
А если перехода нет, то придётся добавить новую вершину, сдвинуть FNL и повторить всё заново.
Добавление рёбер и вершин работает быстро, так как итоговый размер линеен и мы ничего не удаляем, а вот с поиском нового FNL возникают проблемы.
Для этого будем использовать, как ни странно, суффиксные ссылки.

\textbf{Определение.} $\path(pos)$ --- строка, по которой мы приходим в позицию $pos$.
Аналогично определяется $\path(v)$ для вершины $v$.

\textbf{Определение.} $\suff(v)$ --- это такая позиция $pos$, что $\path(pos)$ --- это суффикс $\path(v)$ и $|\path(pos)| = |\path(v)| - 1$.

\textbf{Утверждение.} Если $v$ --- не лист, то $\suff(v)$ --- это вершина (а не позиция посреди ребра).

\textbf{Доказательство.} Рассмотрим вершину $v$. Пусть $Q = \path(v)$, $Q'$ --- строка $Q$ без первого символа.
Так как дерево сжатое, у вершины $v$ есть хотя бы два потомка со строками $Qa$ и $Qb$, которые являются подстроками.
Но тогда и $Q'a$ с $Q'b$ являются подстроками.
Замечаем, что вершина, отвечающая строке $Q'$ --- в точности суффиксная ссылка (это вершина, так как степень --- хотя бы 2).

Однако в процессе алгоритма может случится такое, что по суффиксной ссылке вершины всё-таки нет.
Получается, доказательство некорректное? Нет, просто вершина должна добавиться на этом шаге, так что в этом случае вершину можно просто добавить.

Теперь к подсчёту суффиксных ссылок.
Наивный способ: если родитель --- не корень, то перейдём по суффиксной ссылке родителя, потом пройдём по строке, по которой мы поднялись в родителя.
Если же родитель --- корень, то пропускаем шаг перехода по суффиксной ссылке.
Так, мы поднимаемся в родителя и переходим по суффиксной ссылке за константу, а потом спускаемся за количество вершин на пути, откуда получается квадрат.

А точно квадрат?

\textbf{Определение.} Глубина вершины $d(v)$ --- количество рёбер на пути от корня до $v$. Здесь мы именно считаем настоящие, не сжатые, рёбра.

\textbf{Утверждение.} Для любой вершины $v$ $d(\suff(v)) \ge d(v) - 1$.

\textbf{Доказательство.} Посмотрим на $A$ --- путь от корня до $v$ и на $B$ --- путь от корня до $\suff(v)$.
Заметим, что из каждой вершины на пути $A$ суффиксная ссылка ведёт в точности на вершину на пути $B$, кроме, возможно, самой первой (если длина её строки равна 1, то в корень, иначе в $B$).
Отсюда искомая оценка.

Внимательно посмотрим на то, как изменяется глубина вершины FNL.
Изначально она равна нулю.
При переходе по суффиксной ссылке она уменьшается не более, чем на 1, при переходе в родителя --- ещё на 1.
А во время спуска она как-то увеличивается, но больше длины строки она стать не сможет.
Следовательно, суммарно глубина изменяется не более, чем на $3n$.

\subsection{Суффиксный массив}
Будем индексировать строку с нуля, $i$-ый суффикс --- суффикс с $i$-ой позиции.
Есть всякие дурацкие способы построения, но мы будем рассматривать алгоритм Карпа-Миллера-Розенфельда за $O(|S| \log(|S|))$.
Хотя и есть способы за $O(|S|)$ (например, из суффиксного дерева), но в общем случае, когда размер алфавита не ограничен и буквы --- это камешки, которые мы умеем только сравнивать, лучше не получится.

Припишем в конец $\#$ и будем сортировать циклические сдвиги.
Будем сортировать сдвиги длины 1, 2, 4, и так далее $O(\log(|S|))$ раз.
Первую итерацию можно отсортировать любой сортировкой, теперь присвоим всем суффиксам классы эквивалентности и будем сортировать подсчётом пары.
Неасимптотическая оптимизация: можно пары сортировать не в две сортировки, а в одну, так как можно переиспольозвать информацию об отсортированности суффиксов меньшей длины.

\subsubsection{Поиск подстроки в строке за $O(|P| + \log(|S|))$}
Найдём подстроку $P$ в строке $S$ используя хэши, бинарный поиск и... суффиксный массив.

\textbf{Определение.} $\LCP(S, T)$ --- самый длинный общий префикс строк $S$ и $T$.

Сделаем бинарный поиск по суффиксному массиву, пусть $l$ и $r$ --- границы, $lcpL, lcpR$ --- соответствующие LCP.
Мы знаем, что $l$-ый суффикс меньше $P$, а $r$-ый суффикс --- больше.

\textbf{Инвариант.} 
\begin{itemize}
    \item $S[sa_l..|S|-1] < P < S[sa_r..|S|-1]$.
    \item $lcpL = \LCP(S[sa_l..|S|-1], P)$.
    \item $lcpR = \LCP(S[sa_r..|S|-1], P)$.
\end{itemize}
Не умаляя общности, $lcpL \le lcpR$, сравним $mid$-тый суффикс со строкой $P$.
Хотелось бы сказать, что $lcpM$ можно просто увеличивать, так как суммарно LCP границ не уменьшается.
Но если зайти за $lcpR$, то прогресс придётся сбросить и асимптотика сломается.
Поэтому можно использовать хэши, чтобы проверить, правда ли, что $lcpM \ge lcpR$, и потом уже двигаться по-одному.

\subsubsection{Массив LCP}
\textbf{Определение.} $lcp$ --- массив, такой что 
\[
    lcp[i] = \LCP(S[sa_i..|S|-1], S[sa_{i+1}..|S|-1]).
\]

\textbf{Утверждение.} LCP $i$-ого и $j$-ого суффикса для $i < j$ --- это\\ $\min(lcp[i], lcp[i + 1], \dots, lcp[j])$.
В качестве упражнения.

\textbf{Замечание.} $lcp$ позволяет быстро строить суффиксное дерево.

Построить можно алгоритмом Аримуры-Арикавы-Касаи-Ли-Парка.
Для доказательства асимптотики рассмотрим два соседних суффикса, удалим первый символ и посмотрим на значения LCP $i$-ого и $(i-1)$-ого суффикса.

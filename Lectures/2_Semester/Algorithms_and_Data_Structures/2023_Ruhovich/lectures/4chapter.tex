\section{Link-Cut Tree}




Сегодня будут изменяемые деревья. В HLD у нас дерево фиксировано и на каждом ребре что-то написано и мы хотим делать всякие операции на путях (все, что умеет ДО). Все это мы научились делать за O(log n), или $O(log^2 n)$ попроще. Теперь представим, что у нас есть несколько деревьев и мы хотим все еще хотим делать все обычные ДОшные операции, и еще areInOnTree(u, v), link(u, v), cut(u, v) (проверить, в одном ли дереве две вершинки; объявить, что у корня v теперь родитель u; удалить ребро, в котором u родитель v (появляется новое дерево где v корень)). А еще введем функцию evert(u) (хотя более точное название makeRoot(u)) - поменять корень в дереве. И еще давайте пусть будет операция LCA(u, v), isAncestor(u, v), isParent(u, v). Давайте запишем Эйлеров обход (замечание: формально в дереве нет эйлерова обхода, а если есть, то это бамбук, потому что Эйлеров обход - это проход по дереву по каждому ребру ровно по 1 разу, а для нашего случая давайте представим, что каждое ребро - это два ориентированных ребра в разные стороны, тогда тут уже существует Эйлеров обход, т. е. когда мы для LCA с помощью Sparse Table делали inOrder обход дфсом, это и был Эйлеров обход). Давайте представим, что нет запросов на смену корня. Заметим, что наш обход - это просто последовательность вершин. Давайте хранить ее для каждого дерева в каком-нибудь ДДП, которая умеет делать split, merge и т. д. за O(log n). Тогда, чтобы сделать cut - просто вырежем подпоследовательность, и (как мы когда-то ранее доказывали) это как раз и будет поддеревом. Тогда в оригинальной последовательности это поддерево пропадет, и нам придется еще удалить вершинку u, т. к. она тогда шла бы два раза подряд (до того поддерева, и после того поддерева). Для этого в вершинке можно хранить ее первое и последнее вхождение в эту последовательность. Еще в нашей последовательности давайте хранить глубину у каждой вершины, чтобы искать LCA, но делать это будем не спарсами, а нашим ДДП (и легко это изменять операцией += при линке и -= при кате). isParent делаем как угодно - можно посмотреть предыдущую вершину в обходе, можно сравнить глубины и запустить LCA, можно еще как-нибудь. Для AreInOnTree(u, v) просто найдем корень каждого из деревьев у u и v и сравним эти корни. Но есть недостаток у такого подхода - нам не получиться делать операции на отрезке (например сумму и присваивание), хотя можно даже сдвигать корень, но там тоже все ломается. Но мы сейчас научимся все делать, причем за O(log n), но правда амортизированно. "Мы не смогли смажорировать HLD, хотя и делаем все быстро, но за это мы платим... монетки".



Link Cut Tree.
Идея вытекает из HLD. Выделим в дереве какие-нибудь красные пути и соединим эти красные пути какими-нибудь синими ребрами. Ограничение одно - все красные ребра образуют набор путей. Может быть и n путей по одной вершине в каждом, может быть 1 путь (если у нас бамбук), больше никаких инвариантов нет. Тогда у нас красных ребер вообще может даже и не быть. Заметим, что красный путь это массив, и давайте хранить их в ДДП (и около корня будем хранить информацию о возможном синем ребре в предка). Заметим, что Link никак не меняет пути, поэтому мы легко можем делать эти запросы. С cut'ом посложнее - если мы удаляем синее ребро, мы теперь говорим его ребенку что у него теперь нет родителя. Если ребро красное, то путь пилим на 2 (такое ДДП умеет) и все круто. Чтобы делать запросы на путях нам не получиться просто идти по красным путям и брать запрос, потому что в HLD у нас на пути было не более чем O(log n) синих ребер (ну и красных путей), а тут у нас такого может и не быть. Ключом решения всех проблем будет функция EXPOSE(u). Она будет как-то менять красные пути на пути от u до корня так, чтобы у нас получался один путь от корня до u, для этого все синие ребра меняем на красные, а все красные ответвления перекрашиваем в синий (одно ребро), другими словами меняем минимальное кол-во ребер так, чтобы был целый красный путь от u до корня. Теперь evert(u) очень легко сделать - сделаем EXPOSE(u) и в ДДП отреверсим этот красный путь (и заметим, что все остальные красные пути от этого не поменялись и нам ничего не надо больше менять). Давайте теперь научимся и все остальное делать через EXPOSE. Чтобы сделать isAncestor и isParent сделаем EXPOSE и проверим, что вторая вершинка лежит на пути до корня. Для LCA(u, v) для начала проверим, является ли кто-то из них предком другого, и если нет, то делаем EXPOSE(u) и потом EXPOSE(v), тогда пусть от корня до u распиливается на 2 и уходит в v, причем распиливание происходит ровно в точке LCA. Тогда просто возьмем самую верхнюю вершинку в ДДП у u и возьмем ее предка (за O(log n)). Для всех операций просто делаем EXPOSE и делаем теперь запрос на подотрезке (сделаем u корнем и делаем EXPOSE(v)). То есть мы умеем делать абсолютно все с помощью EXPOSE.

Давайте мысленно у каждой вершины считать sz(v). Ребра бывают красные, а бывают синие. А еще ребра бывают тяжелые, и легкие. Давайте введем потенциал Ф := количество красных легких ребер во всех деревьях. Утверждение: с таким потенциалом учетная стоимость EXPOSE(u) - O(log n). Давайте докажем, что с таким условием все остальные операции не ломают потенциал. Операции LCA, isParent, isAncestor никак не меняют структуру дерева помимо EXPOSE. А вот например evert помимо экспоуза делает еще и реверс на отрезке, поэтому тяжело-легкая структура может поменяться. Утв.: перед реверсов на пути было логарифм легких ребер (ранее доказывали), а после разворота их стало не более чем логарифм, то есть поменялось не более чем |log n| ребер.
Прикол: на самом деле красные ребра называются сплошными, а синие - пунктирными.
Анекдот: у Хабаровских китайцев есть традиция - и это должно нас настораживать.
Вспомним, как мы делали Cut. Сделав EXPOSE(u) у нас получился красный путь от u до корня, и после отпила тяжело-легкось могла поменяться только у ребер с красного пути от u до корня и может быть каких-то соседних, но у красных она смогла поменяться только у ребер на пути, перед отпиливанием было не более логарифма ребер, и после отпила стало не более логарифма, поэтому потенциал изменился не более чем на логарифм. Аналогично, в Linkе у нас потенциал тоже изменяется не более, чем на логарифм, причем в линке он уменьшается, а в кате увеличивается. 
Итак, финал: осталось доказать только то, что у нас EXPOSE(u) работает амортизированно за O(log n), и после этого весь алгоритм будет доказан.

EXPOSE для начала отпиливает у u ребеночка (меняет цвет на синий), это происходит за O(log n) и потенциал может только уменьшиться на единицу (или не измениться). Потом мы идем до корня и каждый раз делаем одно синее ребро красным (merge двух деревьев) и же одно красное ребро делает синим, причем эта операция (замена двух ребер) называется SPLICE и может как уменьшить потенциал, так и увеличить его на единицу. Нам остается доказать, что в среднем сплайсов происходит логарифм за экспоуз. Сплайсы бывают разными. 1) ребро было синим и стало красным, в нем потенциал мог увеличиться не более чем на 1, если ребро легкое, но таких всего ребер не более чем логарифм.
Изменим потенциал: кол-во красных легких ребер + кол-во синих ребер. Линки и каты по модулю меняют кол-во синих ребер ребер на 1, поэтому ничего плохого не произошло из-за такого изменения.
В первом варианте сплайса мы меняем только одно синее на одно красное ребро, и если оно тяжелое, то потенциал меняется на 0 - 1 = -1, а если легкое, то 1 - 1 = 0 - то есть <= $log_2(n)$ на экспоуз, потому что таких синих ребер логарифм. Рассмотрим другие случаи. Допустим красным было легкое ребро, и после перекраски красное все еще легкое (2). Могло быть так, что было легким и стало тяжелым (3), а могло быть так, что было тяжелым и стало легким (4). Не бывает случая из тяжелого в тяжелый, т. к. по определению тяжести не бывает у вершины 2 тяжелых ребра.
(2) - потенциал меняется на 0 + 0 = 0, и такое происходит тоже не более чем логарифм раз на экспоуз.
(3) - потенциал -1 + 0 = -1, то есть уменьшился.
(4) - потенциал 1 + 0 = 1, таких случаев тоже происходит не более чем логарифм раз на экспоуз.
Таким образом учетное число сплайсов - логарифм. Таким образом, сделав Q экспойузов, число сплайсов O(Q * log n). Утверждение: за экспоуз происходит в среднем логарифм сплайсов и меняют потенциал они не более чем на логарифм. То есть учетное кол-во сплайсов на каждую операцию логарифм. То есть если ко всему линк кату было Q запросов, то всего сплайсов было O(Q log n). Имея тривиальную оценку на сплайс O(log n) времени имеем, что каждый запрос в линк кат делается за $O(log^2 n)$. Оказывается, что если в качестве ДДП использовать Splay Tree, то все будет работать за O(log n). 

Для этого в сплее введем другой потенциал. Давайте введем такой потенциал, что относительно него сплайс будет работать за O(log n). Пусть Ф := $sum(log(sum(w_v))) (= sum_{v}(log_2(S_v)))$ (просто добавили потенциал от сплей дерева). В этом потенциале стоимость операций сплея $O(log(W/w_v))$.

Давайте в сплее, который работает за $O(log(W/w_v))$ выберем $w_v$ так, чтобы у нас сплайс работал за логарифм. Посмотри на красный путь - он хранится в сплей дереве, в каждом вершине подвешено синее поддерево. Тогда $w_v$ := размер синего поддерева (считая себя, то есть $w_v$ >= 1). Если вспомнить все операции, то все, кроме экспоуза линка и ката не меняет этот вес.

В кате все норм, а в линке мы создаем синее ребро, и это может быть проблемой - сумма весов поддерева поменяется у всех предков измененной вершины. Поэтому давайте перед тем, как что-то подвешивать к u, будем объявлять его корнем сплей дерева (в корневом дереве) (то есть сделали EXPOSE(u), splay(u)). Вес увеличивается не более чем на n, и сумма поддерева увеличивается не более чем на n, тогда логарифм S увеличился не более чем на log n. При кате сплей можно не делать, т. к. потенциал только уменьшается. В everte reverse никак не меняет потенциал (потому что это обычная отложенная операция для сплея) и все остальные операции тоже.

Финальный финал: EXPOSE(u). Когда мы меняем цвет с красного на синий у ребра, с точки зрения сплея у нас происходит сплит и все поддерево уходит, а с точки зрения линк ката у нас уменьшилась $S_u$ на размер всего удаленного поддерева, но $w_u$ увеличилась на ту же величину, получается тогда и $S_u$ тоже увеличилась, то есть потенциал никак не поменялся. То есть начало экспоуза потребовало нам один сплей (учетно за логарифм). Теперь мы будем идти и мерджить сплей деревья (делать сплайсы). Первый мы сделаем за $splay(v_1)$ + отпил/подвес + запил (при отпили и запили потенциал не меняется, как мы выяснили чуть чуть выше), то есть за один сплей (перед тем как делать сплайс у вершинки мы делаем от нее сплей). То есть мы все сделали за $O(log_2(W_1/w_{v_1})  + 1) + O(1) + O(1)$, где $W_i$ - размер всего поддерева в линк кате (всего вообще поддерева, которое висит на пути). Далее мы все это поддерево (сплея) где $v_1$ корень хотим подвесить к $v_2$, и аналогично мы это делаем за $O(log_2(W_2/w_{v_2}) + 1)$, пусть мы сделали это все k раз (замечание: k - учетно - логарифм, а реально - какое угодно), тогда эта сумма не превосходит O(k) (сумма единичек) + $O(log_2(W_1) - log_2(w_{v_1}) + \cdots + log_2(W_k) - log_2(w_{v_k}))$. Заметим, что при переходе от $v_1$ к $v_2$ ее вес ($W_2$) строго больше, чем вес у $v_1$, поэтому там все сократится и будет <= O(k) + $O(log_2(W_k/w_{v_k}))$ = O(k + log n). То есть за Q запросов суммарно мы сработаем за $O(Q log n + sum(k_i))$. Мы уже ранее доказали то, что $sum(k_i)$ = O(Q log n), то есть за все время мы сработаем за O(Q log n), получается каждый запрос работает за O(log n), победа!
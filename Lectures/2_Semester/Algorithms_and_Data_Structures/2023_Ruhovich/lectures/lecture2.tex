\subsection{Алгоритмы поиска величины потока}

\subsubsection{Алгоритм Эдмондса-Карпа}

Все это время у нас не было никакого конкретного алгоритма для поиска потока -- всегда были какие-то черные ящики, с помощью которых мы искали пути по ненасыщенным ребрам.

\begin{problem}
    Дан двудольный граф без кратных ребер, где степень каждой вершины равна $d$ (двудольный $d$-регулярный граф, $d \geq 1$). Докажите, что в нем найдется совершенное паросочетание.
\end{problem}

\begin{solution}
    Доказательство примерно такое же, как в лемме Холла. Читателю предлагается найти его в качестве упражнения.
\end{solution}

\begin{corollary}
    Ребра графа можно разбить на $d$ совершенных паросочетаний.
\end{corollary} 

\noindent Метод Форда-Фалкерсона предлагает искать путь, например, DFSом. Тогда время его работы с целочисленными пропускными способностями будет, очевидно, $O((V + E) * |F|) = O(E|F|)$, где $|F|$ -- величина максимального потока. В правильно построенной нецелочисленной сети метод Форда-Фалкерсона не сможет сойтись к правильному ответу спустя сколь-угодно много итераций, и даже не будет сходиться к нему в пределе.

\begin{algorithm}[Эдмондса-Карпа]
    Давайте теперь на каждом шаге метода Форда-Фалкерсона находить путь с помощью BFS
\end{algorithm}

\begin{lemma}
    В процессе Э-К $\forall v \in V: dist_{g_{f_{cur}}} (s, v)$ (расстояние по количеству ребер по ненасыщенным ребрам) не уменьшается.
\end{lemma}

\begin{proof}
    Посмотрим на наш BFS. Есть стартовая вершина (нулевая), есть вершины слоя $1, 2, 3, \ldots, k, \ldots$, и пусть в $k$-ом слое лежит вершина $t$. Ребра могут идти из слоя в любой другой слой с меньшим номером, с таким же номером, либо с номером максимум на 1 больше. Теперь пусть мы нашли какой-то путь до $t$, и пусть он не проходит по вершине $v$. Пропустим по нему поток, какие-то ребра пропадут, какие-то появятся. Заметим, что появившееся ребра могут быть только обратными, и ведут в слой с меньшим номером, чем их начало. Посмотрим, как поменялось расстояние от $s$ до $v$, но при этом будем рассматривать текущие разбиение на слои. Заметим, что как бы на самом деле не поменялись слои, каждое старое ребро увеличивает номер слоя не более чем на 1, а новые ребра уменьшают номер слоя, поэтому какой бы путь мы не нашли, количество ребер в нем будет не меньше, чем в прошлый раз.
\end{proof}

\begin{lemma}
    Любое ребро может быть насыщенно (в процессе Э-К) не более $\frac{|V|}{2}$ раз.
\end{lemma}

\begin{proof}
    Рассмотрим ребро $(u, v)$. Если мы пустили по нему поток, то $dist(u) = d, dist(v) = d + 1$. Чтобы насытить его еще раз, надо его разнасытить, то есть насытить ребро $(v, u)$, но тогда должно быть $dist(v) \geq d + 1, dist(u) \geq d + 2$. Заметим, что для повторного насыщения ребра нужно его расстояние увеличить хотя бы на 2. Максимальное возможное расстояние в графе -- $|V|$.
\end{proof}

\begin{corollary}
    Суммарное количество насыщений будет $O(VE)$.
\end{corollary}

\begin{theorem}
    Алгоритм Эдмондса-Карпа работает за $O(VE^2)$.
\end{theorem}

\begin{proof}
    Для каждого насыщения мы используем BFS, который работает за $O(V + E)$, получаем асимптотику $O(VE * (V + E)) = O(VE^2)$.
\end{proof}

\subsubsection{Концепция блокирующих потоков}

\begin{definition}
    Слоистая сеть -- это сеть $G = (V, E, c, s, t)$, где $\forall e \in E: dist_g(s, e.start) + 1 = dist_g(s, e.finish)$.
\end{definition}

\noindent Другими словами, все ребра ведут в ``следующий слой'' BFSа. \\
Чтобы ее получить, можно просто запустить BFS и временно начать игнорировать все ребра, которые ведут не в следующий слой.

\begin{definition}
    Пусть $G = (V, E, c, s, t)$ -- сеть, а $f$ -- поток в ней. Тогда $f$ блокирующий, если в $G$ не существует пути из $s$ в $t$ по ненасыщенным ребрам.
\end{definition}

\begin{note}
    Путь не должен существовать именно в $G$, а не в $g_f$. Другими словами, любой увеличивающий путь должен уменьшать текущий поток по некоторым ребрам.
\end{note}

\begin{definition}
    Концепция блокирующих потоков: \\
    while (есть путь из $s$ в $t$ в $G_f$):
        \begin{itemize}
            \item Запускаем BFS в остаточной сети, строим слоистую сеть
            \item Строим в слоистой сети блокирующий поток
        \end{itemize}
\end{definition}

\begin{theorem}
    В концепции блокирующих потоков выполняется не более чем $|V|$ итераций цикла while.
\end{theorem}

\noindent Истинность этой теоремы следует из следующей теоремы.

\begin{theorem}
    Каждая итерация в КБП (концепции блокирующих потоков) строго увеличивает расстояние $dist_{g_f} (s, t)$ в остаточной сети.
\end{theorem}

\begin{proof}
    Пусть мы построили слоистую сеть и нашли какой-то увеличивающий поток. Допустим, мы нашли какой-то блокирующий поток. Заметим, что т. к. мы в слоистой сети, каждое новое ребро является обратным. Если бы расстояние от $s$ до $t$ не изменилось, то изначальный поток был не блокирующим.
\end{proof}

\noindent Остался только один черный ящик -- способ поиска блокирующего потока. Рассмотрим алгоритм Диница, в котором мы просто ищем его DFSом в слоистой сети. Это довольно простая и тупая идея, однако у нее есть и свои плюсы.

\begin{proposition}
    Если DFS не нашел продолжения пути до $t$ по какому-то ребру $e$, то по нему не будет пути до $t$ больше никогда.
\end{proposition}

\begin{proof}
    Заметим, что в слоистой сети в процессе поиска потока новые ребра не появляются (т. к. появляются только обратные, которые мы игнорируем), поэтому нового пути появиться не может.
\end{proof}

\begin{corollary}
    Пусть мы ищем путь в слоистой сети. Пусть оказалось, что мы прошли по какому-то ребру, и вернулись, не найдя пути до $t$. Тогда можно его добавить в игнор так же, как и все ребра не из слоистой сети, таким образом DFS не будет в него даже заходить. Тогда DFS будет работать за $O(|E_{deleted}| + l + v)$, где $l$ -- это расстояние от $s$ до $t$. Тогда суммарно все DFSы для поиска одного блокирующего потока будут работать за $O(|E| + l|E|) = O(VE)$ (т. к. суммарно будет $O(|E|)$ удалений ребра). Так как итераций $O(V)$, то мы получаем алгоритм, работающий за $O(V^2E)$.
\end{corollary}

\subsubsection{Реализация Алгоритма Диница}

\begin{lstlisting}
    template <typename TVertex, typename TFlow>
    struct Edge {
        TVertex start, finish;
        TFlow capacity, flow;
    };

    class Network {
    private:
        TVertex verticesNumber_, source_, sink_;
        vector<Edge<TVertex, TFlow>> edges_;

        vector<vector<size_t>> graph_;

        void addEdgeLocal_(TVertex start, TVertex finish, 
                    TVertex capacity) {
            graph_[start].push_back(edges_.size());
            edges_.emplace_back(start, finish, capacity, (TFlow)0);
        }

        void push_(size_t edgeNumber, TFlow flow) {
            edges_[edgeNumber].flow += flow;
            edges_[edgeNumber ^ 1].flow -= flow;
        }

    public:
        Network(TVertex n, TVertex s, TVertex t)
            : verticesNumber_(n),
            source_(s),
            sink_(t),
            edges_(),
            graph_(n, []) {
            assert(0 <= s && s < n && 0 <= t && t < n);
        }

        void addEdge(TVertex start, TVertex finish, TVertex capacity) {
            addEdgeLocal_(start, finish, capacity);
            addEdgeLocal_(finish, start, 0);
        }

        class EdgeIterator {
        private:
            Network& myNetwork_;
            TVertex vertex_;
            size_t index_;

            size_t getIndexInEdgesList_() const {
                return myNetwork_.graph_[vertex_][index_];
            }

            const Edge& myEdge_() {
                return myNetwork_.edges_[getIndexInEdgesList_()];
            }

            Edge& myEdge_() {
                return myNetwork_.edges_[getIndexInEdgesList_()];
            }

        public:
            explicit EdgeIterator(Network<TVertex, 
                    TFlow>& myNetwork, TVertex v)
                : myNetwork_(myNetwork), vertex_(v), index_(0) {

            }

            bool valid() const {
                return index_ < network_.graph_[vertex_].size();
            }

            void next() {
                ++index_;
            }

            TVertex getStart() const {
                return myEdge_().start;
            }

            TVertex getFinish() const {
                return myEdge_().finish;
            }

            TFlow getCapacity() const {
                return myEdge_().capacity;
            }

            TFlow getFlow() const {
                return myEdge_().flow;
            }

            TFlow getRedisualCapacity() const {
                return getCapacity() - getFlow();
            }

            bool isSaturated() const {
                return getRedisualCapacity() == (TFlow)0;
            }

            void pushFlow(TFlow f) {
                assert(TFlow(0) <= f && f <= getRedisualCapacity());
                myNetwork_.push_(getIndexInEdgesList_(), f);
            }

        };

        friend class Network::EdgeIterator;

        EdgeIterator begin(TVertex v) {
            return EdgeIterator(v);
        }

    };

    template <typename TVertex, typename TFlow>
    class DinitzAlgorithm {
    private:
        using NetworkIterator_ = Network<TVertex, TFlow>::EdgeIterator;

        Network<TVertex, TFlow>& network_;
        vector<size_t> dst_;
        TVertex n_, s_, t_;
        vector<NetworkIterator_> iterators_;

        bool bfs_() {
            dst_.assign(n_, n_);
            queue<TVertex> q;
            q.push(s_);
            dst_[s_] = 0;

            while (!q.empty()) {
                TVertex v = q.front();
                q.pop();

                for (NetworkIterator_ it = network_.begin(v);
                    it.valid();
                    it.next()) {
                    if (!it.isSaturated()) {
                        size_t nv = it.getFinish();
                        if (dst_[v] + 1 < dst_[nv]) {
                            dst_[nv] = dst_[v] + 1;
                            q.push(nv);
                        }
                    }
                }
            }

            return dst_[t_] != n_;
        }

        void initIterators_() {
            iterators_.clear();
            for (TVertex v = 0; v < n_; ++v) {
                iterators_.emplace_back(network_.begin(v));
            }
        }

        TFlow dfs_(TVertex v, TFlow f) {
            if (v == t_) 
                return f;

            TFlow ans = 0;
            for (NetworkIterator_& it = iterators_[v];
                it.valid();
                it.next()) {
                if (it.isSaturated())
                    continue;
                if (dst_[it.getStart()] + 1 != dst_[it.getFinish()])
                    continue;
                TFlow nf = std::min(f, it.getRedisualCapacity);
                Tflow res = dfs_(it.getFinish(), nf)
                if (res) {
                    it.push(res);
                    return res;
                    
                }
            }

            return 0;
        }

    public:
        explicit DinitzAlgorithm(Network<TVertex, TFlow> &network)
            : network_(network) {}

        void run() {
            n_ = network_.getVerticesNumber();
            s_ = network_.getSource();
            t_ = network_.getSink();

            while (bfs_()) {
                initIterators_();
                while (dfs_(s_, std::limits<TFlow>::max())) {

                }
            }
        }
    };

    template <typename TVertex, typename TFlow>
    TFlow runDinitz(Network<TVertex, TFlow>& network) {
        DinitzAlgorithm<TVertex, TFlow> algo(network);
        algo.run();
        assert(network_.isCorrectFlow());
        return network_.getFlowSize();
    }
\end{lstlisting}

\noindent Однако можно немного оптимизировать DFS:

\begin{lstlisting}
    TFlow dfs_(TVertex v, TFlow f) {
        if (v == t_) 
            return f;

        TFlow ans = 0;
        for (NetworkIterator_& it = iterators_[v];
            it.valid();
            it.next()) {
            if (it.isSaturated())
                continue;
            if (dst_[it.getStart()] + 1 != dst_[it.getFinish()])
                continue;
            TFlow nf = std::min(f, it.getRedisualCapacity);
            Tflow res = dfs_(it.getFinish(), nf)
            if (res)
                it.push(res);
            ans += res;
            f -= res;

            if (f == 0)
                return ans;
        }

        return ans;
    }
\end{lstlisting}

\noindent Проблема обычного Диница в том, что если у нас бамбук из ребер пропускной способности 1000, а потом из одной вершинки 1000 ребер пропускной способности 1, которые потом ведут в сток, то алгоритм будет каждый раз проходить по всем 1000 вершинам бамбука при добавлении единички в поток. Улучшенная же реализация, дойдя до вершинки из которой исходит 1000 ребер, пройдет сразу по ним всем. Однако, это все равно спорно и асимптотика, скорее всего, будет точно такая же.

\subsubsection{Единичные сети}

\begin{definition}
    Единичная сеть -- сеть, в которой у всех ребер пропускная способность равна единице. Особенностью является то, что каждое ребро либо насыщено, либо нулевое. Причем в остаточной сети всегда есть либо оригинальное ребро, либо обратное ему.
\end{definition}

\begin{note}
    Любую сеть, в которой все пропускные способности равны, можно свести к единичной, путем простой замены значений.
\end{note}

\begin{problem}
    За какую асимптотику работает алгоритм Диница в единичной сети?
\end{problem}

\begin{solution}
    Ответ $O(V^2E)$, очевидно, верный, но давайте оценим точнее. Заметим, что в единичной сети при пропускании потока мы убиваем не одно насыщенное ребро, а целый путь насыщенных ребер (так как каждое ребро на пути становится насыщенным). Поэтому все DFSы в сумме будут работать за $O(E)$, так как каждое рассмотренное однажды ребро будет убито. Тогда весь алгоритм работает за $O(VE)$, но можно оценить еще точнее.
\end{solution}

\begin{theorem}
    Любой поток можно декомпозировать на не более чем $|E|$ путей и циклов.
\end{theorem}

\begin{proof}
    Пусть есть сеть с потоком $f$. Если $f > 0$, то из вершины $s$ вытекает хоть по одному ребру какая-то вода. Тогда в той вершине, куда этот поток втекает, найдется ребро, по которому поток вытекает (по одному из свойств потока). Пройдем так до вершины $t$ и найдем $f_{min}$ на пути, вычтем его из каждого ребра и получим, что какое-то ребро разнасытилось, и мы нашли один из путей в декомпозиции. Если же мы уткнулись в цикл, то вычтем поток из всего цикла, и добавим цикл в декомпозицию. Заметим, что через не более, чем $E$ итераций, из $s$ будет вытекать 0 единиц потока. Однако это не значит, что на всех ребрах поток равен нулю. Если вдруг есть ребро с ненулевым потоком, то легко понять, что в сети остались только какие-то циклы, которые тоже можно декомпозировать аналогичным образом.
\end{proof}

\begin{theorem}
    При поиске потока с помощью КБП в единичной сети будет выполнено не более чем $2 \sqrt{E}$ итераций цикла while.
\end{theorem}

\begin{proof}
    Пусть мы выполнили $k$ итераций Диница, давайте посмотрим на остаточную сеть. Тогда расстояние от $s$ до $t$ больше, чем $k$ (т. к. каждый раз расстояние увеличивается, по доказанному раннее). Давайте декомпозируем максимальный поток в остаточной сети, получим пути длины хотя бы $k + 1$, и т. к. сеть единичная, то всего различных путей (и, соответственно, итераций алгоритма) осталось не более, чем $\frac{|E|}{k + 1}$, назовем это число $F_{left_k}$. Давайте проделаем $k = \sqrt{|E|}$ итераций, тогда останется проделать еще $\frac{|E|}{\sqrt{|E|} + 1} \leq \sqrt{|E|}$ итераций, поэтому всего мы сделаем $O(\sqrt{|E|})$ итераций, и даже больше -- мы сделаем не более, чем $2\sqrt{|E|}$ итераций.
\end{proof}

\begin{corollary}
    Время работы алгоритма Диница в единичной сети: $O(E\sqrt{E})$.
\end{corollary}

\begin{note}
    В двудольном графе с нашей структурой поиска максимального паросочетания у каждой вершины (кроме $s$ и $t$) никогда не меняется сумма исходящих и входящих пропускных способностей в остаточной сети.
\end{note}

\begin{proposition}[Алгоритм Хопкрофта-Карпа]
    Можно найти максимальное паросочетание в графе за $O(E\sqrt{V})$.
\end{proposition}

\begin{proof}
    Доказательство точно такое же, как в теореме выше, но заметим, что из-за структуры графа можем считать, что $F_{left_k} \leq \frac{|V|}{k}$, т. к. из замечания выше следует, что пути в остаточной сети не пересекаются не только по ребрам, но и по вершинам (т. к. степень вхождения или исхождения каждой вершины кроме истока и стока всегда равна единице). Возьмем $k = \sqrt{|V|}$, получаем, что всего будет сделано $O(\sqrt{V})$ итераций за $O(E)$ времени.
\end{proof}

\begin{problem}
    Дан двудольный граф, $10^6$ вершин, $2 * 10^6$ ребер. Нужно найти ``почти максимальное паросочетание'' (его размер должен быть хотя бы 95\% от настоящего максимального паросочетания).
\end{problem}

\begin{theorem}[Умника]
    Эту теорему доказал Алексей Данилюк в своей дипломной работе. Будем искать максимальное паросочетание в двудольном графе с помощью КБП. После $k$ итераций размер уже найденного паросочетания будет не менее, чем $\frac{k}{k+1} * ans$, поэтому просто сделаем 19 итераций и получим, что хотя бы $\frac{19}{20} * ans = ans * 0.95$ ребер входит в наше паросочетание, где $ans$ -- размер максимального паросочетания.
\end{theorem}

\begin{proof}
    Запустим КБП в двудольном графе. Пусть после $k$ итераций размер текущего паросочетания равен $cur_k$. Далее просто посмотрим на остаточную сеть, в ней максимальный поток будет равен тому, на сколько ребер еще можно увеличить паросочетание. Его можно декомпозировать на пути, которые не пересекаются по ребрам и вершинам, из чего следует, что количество путей в декомпозиции совпадает с максимальным потоком и, соответственно, с тем, на сколько еще можно увеличить размер паросочетания. Заметим, что каждый путь является удлиняющей цепью паросочетания, т. к. каждое ребро справа налево является ребром, которое прямо сейчас лежит в нашем паросочетании, и из-за того, что после каждой итерации расстояние от $s$ до $t$ должно было увеличиваться (причем с нашей структурой графа только на четное число), то текущее расстояние (и, соответственно, длина каждого пути в декомпозиции потока) будет хотя бы $2k + 3$, из чего следует, что хотя бы $k$ ребер из паросочетания лежат на каждом пути. Из того, что в каждом пути декомпозиции содержится хотя бы $k$ ребер из паросочетания, что пути не пересекаются по ребрам и вершинам, и что размер паросочетания после $k$ итераций равен $cur_k$ следует, что всего таких различных путей может быть не более, чем $\frac{cur_k}{k}$. Так как количество таких путей это тоже самое, что размер максимального потока и количество ребер, которое надо добавить в наше паросочетание, чтобы получить максимальное, то $ans \leq cur_k + \frac{cur_k}{k}$, где $ans$ -- размер максимального паросочетания в графе, что равносильно $cur_k \geq \frac{k}{k+1} * ans$, что и требовалось доказать.
\end{proof}



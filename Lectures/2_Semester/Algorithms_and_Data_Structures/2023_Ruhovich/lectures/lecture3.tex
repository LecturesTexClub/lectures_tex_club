\subsubsection{Продолжение паросочетаний}

\begin{definition}
    Пусть есть граф $G = (V, E)$. Тогда $\pi(G)$ -- размер максимального паросочетания, $\tau(G)$ -- минимальное вершинное покрытие, а $\alpha(G)$ -- максимальное независимое множество.
\end{definition}

\begin{definition}
    Множество вершин называется вершинным покрытием, если любое ребро графа инцидентно хотя бы одной вершине из этого множества
\end{definition}

\begin{definition}
    Множество вершин называется независимым множеством, если ни одно ребро графа не соединяет две вершины из этого множества
\end{definition}

\begin{proposition}
    $\tau(G) = |V| - \alpha(G)$
\end{proposition}

\begin{proposition}
    $\forall V' \subset V: V'$ -- вершинное покрытие $\Longleftrightarrow V \setminus V'$ -- независимое множество.
\end{proposition}

\begin{proof}
    $V'$ -- вершинное покрытие $\Longleftrightarrow \forall (u, v) \in E: u \in V' \lor v \in V' \Longleftrightarrow \forall (u, v) \in E: \lnot (u \in V \setminus V' \land v \in V \setminus V') \Longleftrightarrow V \setminus V'$ -- независимое множество
\end{proof}

\begin{proposition}
    $\pi(G) \leq \tau(G)$
\end{proposition}

\begin{problem}
    Является ли данная оценка точной?
\end{problem}

\begin{solution}
    Нет. Контрпример -- полный граф на 3 или 4 вершинах.
\end{solution}

\begin{theorem}[Кёнига]
    В двудольном графе $\pi(G) = \tau(G)$.
\end{theorem}

\begin{proof}
    Мы уже знаем, что $\pi(G) \leq \tau(G)$, поэтому надо просто построить покрывающее множество размера $\pi(G)$, тогда будет верно $\tau(G) \leq \pi(G) \implies \pi(G) = \tau(G)$. Возьмем максимальное паросочетание. Есть вершины покрытые паросочетанием, и не покрытые. Ребра покрытые паросочетанием ориентируем слева направо, а остальные ребра справа налево. Возьмем левые вершины непокрытые паросочетанием и запустим из них DFS. Есть доли $L$ и $R$, и в каждой доли есть вершины, которые обошел DFS, и которые он не обошел, посещенные назовем $L^{+}$ и $R^{+}$, остальные $L^{-}$ и $R^{-}$. Утверждается, что $L^{-} \cup R^{+}$ -- вершинное покрытие размера $\pi(G)$.
\end{proof}

\begin{proposition}
    В условиях прошлой теоремы $L^{-} \cup R^{+}$ -- вершинное покрытие размера $\pi(G)$.
\end{proposition}

% \begin{proof}
%     Пусть была вершина из $L^{+}$ покрытая паросочетанием. Тогда каким образом мы в нее попали DFSом? Запуститься из нее мы не могли по определению, а попасть в нее можно было только из $R^{-}$, чтобы опровергнуть утвреждение. Но это невозможно, т. к. $R^{-}$ по определению это непосещенные вершины. Докажем теперь размер. Заметим, что $L^{-}$, по определению, это вершины, которые насыщены паросочетанием. 
    
%     Заметим, что ребра должны идти только из $L^{-}$ в $R^{+}$, иначе вершины из $L^{-}$ были бы посещены DFSом, то есть все ребра насыщены паросочетанием. 
%     НИЧЕ НЕ ПОНЯЛ
% \end{proof}

\begin{corollary}
    $L^{+} \cup R^{-}$ -- максимальное независимое множество
\end{corollary}

\subsubsection{Покрытия}

\begin{problem}
    Дан ориентированный ациклический граф. Хочется покрыть вершины минимальным количеством вершинно-непересекающимся путей.
\end{problem}

\begin{solution}
    Сделаем двудольный граф, где для каждой вершины $u$ из данного графа добавим вершины $u'$ и $u''$. Для каждого ребра $(u, v)$ из исходного графа добавим ребро $(u', v'')$ в новый граф. Тогда ответом будет максимальное паросочетание в этом графе.
\end{solution} %СПРОСИТЬ

\begin{definition}
    Частично упорядоченное множество -- это $(A, \leq)$, где $A$ -- конечное множество, а $\leq$ -- такая функция, что $\forall a, b, c \in A$:
    \begin{enumerate}
        \item $a \leq a$
        \item $a \leq b, b \leq a \implies a = b$
        \item $a \leq b \leq c \implies a \leq c$
    \end{enumerate}
\end{definition}

\begin{definition}
    Пусть $(A, \leq)$ -- ЧУМ. Тогда 
    \begin{enumerate}
        \item $a_1, a_2, \ldots, a_k \in A$ -- цепь, если $a_1 \leq a_2 \leq \ldots \leq a_k$
        \item $a_1, a_2, \ldots, a_k \in A$ -- антицепь, если $\forall i, j: i \neq j \implies a_i \nleqslant a_j$ (любые два элемента несравнимы)
    \end{enumerate}
\end{definition}

\begin{problem}
    Найти минимальное количество (анти-)цепей, которыми можно покрыть ЧУМ.
\end{problem}

\begin{theorem}[Дилворта (Dilworth)]
    В конечном ЧУМе $(A, \leq)$ минимальное количество покрывающих цепей равно максимальному размеру антицепи
\end{theorem}

\begin{proof}
    Истинность тривиально следует из следующих утверждений
\end{proof}

\begin{proposition}
    Количество цепей не меньше, чем размер максимальной антицепи.
\end{proposition}

\begin{proof}
    Каждая цепь содержит максимум один из элементов максимальной антицепи.
\end{proof}

\begin{proposition}
    Размер максимальной антицепи не меньше, чем минимальное количество цепей.
\end{proposition}

\begin{proof}
    Пусть минимальное количество цепей это $K$. Ищем мы эти цепи путем поиска паросочетания в нашем двудольном графе, и $\pi(A') = |A| - K$. Тогда $\alpha(A') = |A'| - \tau(A') = |A'| - \pi(A') = 2|A| - |A| + K = |A| + K$. Рассмотрим это независимое множество, далее для каждой пары вершин (вида $(a', a'')$) выберем вершины, которые выходят в независимое множество -- если только одна из пары, то выберем ее, если обе, то выберем с одним штрихом. Тогда выбранных вершин будет не более, чем $|A|$ (т. к. всего столько пар вершин), тогда невыбранных вершин, которые входят в независимое множество должно быть хотя бы $K$ (т. к. $\alpha(A') = |A| + K$, по доказанному выше). Это значит, что парные с ними вершины тоже входят в независимое множество, и у нас получается хотя бы $K$ пар вершин, между которыми нет ребра, то есть в оригинальном графе есть $K$ вершин, которые друг с другом не сравнимы, то есть антицепь длины хотя бы $K$.
\end{proof}

\begin{problem}
    У вас есть 100 хоббитов, некоторые пары как-то взвешиваются, и если оказывается, что Вася толще Пети, то он его начинает троллить. Надо собрать команду, где никто никого не троллит
\end{problem}

\begin{solution}
    Переформулировка: ``Дан ЧУМ, найдите максимальную антицепь''. Из доказательства теоремы Дилворта явно следует конструктивный алгоритм, который решает данную задачу
\end{solution}

\subsubsection{Масштабирование потока}

\noindent С этого момента все сети будут только целочисленными.

\begin{note}
    Пусть размер максимальной пропускной способности сети не превосходит $C$. Тогда $|f| \leq |E|C$, а метод Форда-Фалкерсона сработает за $O(|E|^2C)$.
\end{note}

\noindent До этого момента асимптотики алгоритмов поиска потока строились в предположении, что мы каждый раз увеличиваем поток на единицу, поэтому давайте попробуем сначала искать пути, по которым можно пропустить поток величины $C$. Пока он находится -- пропускаем по нему, если не нашлось -- уменьшим нижнюю границу потока в два раза и повторим (в итоге сделав $\log_2(C)$ итераций уменьшения). Предположим, что мы только что проделали итерацию, где пропускали потоки размера $2^k$, а теперь хотим пропускать потоки размера $2^{k-1}$. Но раз мы закончили итерацию, то значит, что в остаточной сети нет путей размера хотя бы $2^k$. То есть в остаточной сети существует разрез, через который нельзя пройти в долю, в которой лежит сток (из доли, в которой лежит сток). Этот разрез пересекает не более чем $|E|$ ребер, у каждого из которых пропускная способность менее $2^k$, тогда пропускная способность разреза менее $|E|2^k$, что равно оставшемуся максимальному потоку. Получается, мы сделаем не более чем $\frac{|E|2^k}{2^{k-1}} = 2|E|$ DFSов (может быть, на один больше). Тогда каждая фаза работает за $O(2|E| * |E|)$, всего итераций $\log_2(C)$, получается итоговая асимптотика $O(|E|^2\log(C))$ 

\noindent Теперь представим, что каждая итерация это запуск алгоритма Диница. В нем DFS работает за $O(L + |E_{deleted}|)$, тогда суммарно все DFSы в одной (в $i$-ой) слоистой сети отработают за $O(L_i * col_i + |E|)$. Начнем с того, что все $L_i \leq V$, и еще и $k \leq V$, и конкретно в нашем случае всего путей мы можем найти не более, чем $2|E|$, то есть в сумме асимптотика будет $O(V * (2|E| + |E|)) = O(V|E|)$, и тогда алгоритм Диница с масштабированием будет работать за $O(VE\log(C))$ 

\noindent Временно забудем про то, что сети целочисленные. Есть обычный Диниц, который работает за $O(V^2E)$, каждая фаза работает за $O(VE)$.

\begin{problem}
    Можно ли сделать тоже самое, что делает алгоритм Диница каждую итерацию за $O(VE)$, но при этом асимптотически быстрее?
\end{problem}

\begin{solution}
    Для этого нужно вспомнить, откуда вообще возникает $O(VE)$. Алгоритм находит путь и за $O(V)$ явно его проталкивает, и работает все за $O(V + E_{deleted})$. Чтобы проталкивать поток быстрее, чем за $O(V)$, нам нужно быстрее находить минимум и добавлять его ко всем ребрам на пути. Первое можно просто поддерживать в DFSе, а вот второе можно сделать при помощи Link-Cut Tree, тогда итоговая асимптотика алгоритма Диница с Link-Cut Tree будет $O(VE\log(V))$
\end{solution} %FIX FIX FIX FIX FIX FIX FIX FIX FIX FIX FIX FIX FIX FIX FIX FIX FIX FIX 

% Вернемся к целочисленным сетям.

% Вспомним идею о том, что в единичных сетях алгоритм Диница работает быстрее (за $O(E\sqrt{E})$). Ускорение с одной стороны из-за того, что сразу убивается много ребер. С другой стороны количество фаз блокируюзего потока было $2\sqrt{E}$. Во время поиска парсоча мы усилили эту идею -- фаз будет почти по тем же причинам будет $O(\sqrt{V})$, т. к. пути там не пересекаются не только по ребрам, но и по вершинам. Это было верно из-за того, что у каждой вершины входящая или исходищая степень равна единице.

%Зачем это все вообще нужно?^^^^

\subsubsection{Оценки Карзанова}

\begin{definition}
    Пусть $G = (V, E, c, s, t)$ -- сеть. Пусть $v \in V \setminus \{s, t\}$. Тогда:
    \begin{itemize}
        \item Входящий потенциал $p_{in}(v) \equiv p_{g, in}(v) = \sum_{e \in E, e.finish = v}c(e)$
        \item Исходящий потенциал $p_{out}(v) \equiv p_{g, out}(v) = \sum_{e \in E, e.start = v}c(e)$
        \item Потенциал $p(v) \equiv p_{g}(v) = min(p_{in}(v), p_{out}(v))$
        \item Потенциал сети $P \equiv P_{g} = \sum_{v \in V \setminus \{s, t\}}p(v)$
    \end{itemize}
\end{definition}

\begin{lemma}
    Пусть $G = (V, E, c, s, t)$ -- сеть, а $f$ -- поток в ней. Тогда $\forall v \in V \setminus \{s, t\}: P_{g, in}(v) = P_{g_f, in}(v), P_{g, out}(v) = P_{g_f, out}(v), P_g(v) = P_{g_f}(v), P_g = P_{g_f}$.
\end{lemma}

\begin{theorem}[Первая теорема Карзанова]
    Пусть $G$ -- целочисленная сеть. Тогда любой алгоритм поиска максимального потока в сети $G$, основанный на концепции блокирующих потоков, выполнит не более $O(\sqrt{P_g})$ итераций.
\end{theorem}

\begin{proof}
    После $\sqrt{P_g}$ итераций оставшегося потока будет не более, чем $O(\sqrt{P})$. Мы знаем, что $P_g$ не поменялся, рассмотрим остаточную сеть. Декомпозируем максимальный поток на пути, по каждому из них мы проталкиваем хотя бы единичку потока, длина каждого пути хотя бы $\sqrt{P}$, и из нашего потенциала каждый из этих путей содержит хотя бы $\sqrt{P}$ единиц потока, которого на каждом пути хотя бы $\sqrt{P}$, из этого следует, что самих путей не более, чем $\sqrt{P}$. Поэтому после $\sqrt{P}$ итераций мы сделаем еще не более чем $\sqrt{P}$ итераций.
\end{proof}

\begin{theorem}[Вторая теорема Карзанова]
    Пусть $G$ -- целочисленная сеть без кратных ребер с пропускными способностями не более $C$. После $k$ итераций расстояние от $s$ до $t$ хотя бы $k+1$. Рассмотрим какой-нибудь разрез в слоистой остаточной сети, тогда максимальный поток не превосходит пропускную способность этого разреза. У всех ребер пропускная способность не более $C$, а самих ребер не более чем $2|V_i||V_{i+1}|$ ($V_i$ -- вершины в $i$-ом слое слоистой сети). Тогда величина оставшегося потока не превосходит \\ $2C * min(|V_1||V_2|, |V_2||V_3|, \ldots, |V_k||V_{k+1}|) \leq 2C min((\frac{|V_1| + |V_2|}{2})^2, (\frac{|V_2| + |V_3|}{2})^2, \ldots, (\frac{|V_k| + |V_{k+1}|}{2})^2) = \frac{C}{2}(min(|V_1| + |V_2|, |V_2| + |V_3|, \ldots, |V_k| + |V_{k+1}|))^2 \leq \frac{C}{2}(\frac{\sum_{i=1}^{k}(V_i + |V_{i+1})}{k})^2 \leq \frac{C}{2}(\frac{2|V|}{k}^2) = 2C \frac{|V|^2}{k^2}$
\end{theorem}

\noindent Опять временно забудем про целочисленные потоки.

\begin{problem}[Hard Life]
    Дан неориентированный граф $G = (V, E)$. Хочется найти подграф (выбрать вершины, и выбрать ребра, которые соединяют выбранные вершины) $(V', E')$ у которого плотность ребер ($\frac{|E'|}{|V'|}$) как можно больше (maximal density subgraph).
\end{problem}

\begin{solution}
    Решаем с помощью бинпоиска по ответу, только нужно научиться проверять существование подграфа нужной плотности.
\end{solution}

\begin{problem}
    Дано число $M$. Существует ли подграф плотностью хотя бы $M$? То есть подграф $(V', E')$ такой, что $\frac{2|E'|}{|V'|} \geq M \Longleftrightarrow 2|E'| \geq M|V'|$.
\end{problem}

% \begin{solution}
%     Сделаем каждому ребру пропускную спосбоность равную -1 и найдем минимальный разрез. Проведем еще некоторые ребра способностью $M$.
% \end{solution} ДОДЕЛАТЬ

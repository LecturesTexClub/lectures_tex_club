\subsection{Технологии проталкивания потоков}

\subsubsection{Технология Голдберга}

\noindent В отличие от предыдущих методов поиска потока, сейчас мы не будем обязаны в каждый момент времени иметь корректный поток

\begin{definition}
    Предпоток $f$ в сети $G = (V, E, c, s, t)$ -- это функция $f: E \rightarrow \mathbb{R}$ такая, что:
    \begin{enumerate}
        \item $\forall e \in E: 0 \leq f(e) \leq c(e)$;
        \item $\forall v \in V \setminus \{s, t\}: \sum_{e \in E, e.finish = v}f(e) \geq \sum_{e \in E, e.start = v}f(e)$ (втекать может больше, чем вытекать)
    \end{enumerate}
\end{definition}

\begin{note}
    Любой поток является предпотоком
\end{note}

\begin{note}
    Предпоток можно декомпозировать на циклы и пути, которые могут заканчиваться не в $t$
\end{note}

\begin{definition}
    Высота -- это функция $h: V \rightarrow \mathbb{Z}_{\geq 0}$ такая, что:
    \begin{enumerate}
        \item $h(s) = |V|$
        \item $h(t) = 0$
        \item Высоты остальных вершин меняются (не уменьшаясь), однако $\forall e \in E_f: c_f(e) > 0 \implies h(e.finish) \geq h(e.start) - 1$. Другими словами, ненасыщенные ребра в остаточной сети не могут опускаться больше, чем на 1 единицу высоты
    \end{enumerate}
\end{definition}

\begin{definition}
    Избыток -- это функция $excess(v) = \sum_{e \in E, e.finish = v}f(e) - \sum_{e \in E, e.start = v}f(e)$, где $v \in V$. 
\end{definition}

\noindent Изначально $\forall v \in V \setminus \{s\}: h(v) = 0$, и мы насыщаем все ребра, торчащие из $s$.
Далее изменяем предпоток и высоты, пока хотя бы у одной вершины $v \in V \setminus \{s, t\}$ есть ненулевой $excess$.

\begin{proposition}
    Если в предпотоке все $excess(v) = 0$ -- то в остаточной сети нет пути из $s$ в $t$.
\end{proposition}

\begin{proof}
    Всего вершин $|V|$, а высоты могут быть от 0 до $|V|$. По принципу Дирихле, всегда найдется высота, на которой нет вершин, а значит нет прохода из $s$ в $t$ по ненасыщенным ребрам в остаточной сети (так как каждое такое ребро уменьшает высоту не более, чем на 1)
\end{proof}

\begin{theorem}[Дирихле]
    Пусть мы $nk + 1$ кроликов сажаем в $n$ клеток. Тогда найдется клетка, где лежит $k + 1$ кролик.
\end{theorem}

\begin{proof}
    Пусть это не так, тогда кроликов не больше, чем $nk$.
\end{proof}

\begin{corollary}
    Предпоток, где все $excess(v) = 0$ -- это поток, причем максимальный
\end{corollary}

\noindent Изменять предпоток и высоты разрешается исключительно с помощью функций $push$ и $relabel$ (в другой версии -- $lift$)

\begin{definition}[$push(e \in E_f)$]
    Его цель -- пропихнуть поток по ребру $e$ (но для этого нужен избыток и тот факт, что ребро ненасыщенно и ``смотрит вниз'') \\
    Требования:
    \begin{enumerate}
        \item $excess(e.start) > 0$
        \item $c_f(e) > 0$
        \item $h(e.finish) = h(e.start) - 1$
        \item $e.start \neq s$
    \end{enumerate}
    А делает она следующее:
    \begin{enumerate}
        \item $\Delta f = min(excess(e.start), c_f(e))$
        \item К $f(e)$ и $excess(e.finish)$ добавляет $\Delta f$
        \item Из $f(rev(e))$ и $excess(e.start)$ вычитает $\Delta f$
    \end{enumerate}
\end{definition}

\begin{note}
    Четвертое требование в $push$ ($e.start \neq s$) -- излишне, т. к. изначально все ребра из $s$ насыщены, если какое-то разносытилось -- то его конец стал выше, чем $s$, то есть высоты хотя бы $|V|+1$. Чтобы по нему сделать $push$, нужно чтобы оно смотрело вниз, то есть чтобы было $h(s) > |V| + 1$, что невозможно, т. к. $h(s) = |V|$
\end{note}

\noindent Заметим, что с точки зрения инвариантов она ничего не портит, т. к. она может максимум добавить одно ненасыщенное ребро, но оно будет ``смотреть вверх''

\begin{definition}[$relabel(v \in V \setminus \{s, t\})$]
    Его цель -- поднять вершину на минимальную высоту так, чтобы можно было сделать $push$ и при этом не нарушился бы инвариант. \\
    Требования:
    \begin{enumerate}
        \item $excess(v) > 0$
        \item К каждому ребру из $v$ нельзя применить $push$
    \end{enumerate}
    А в качестве действия мы меняем высоту следующим образом: $h(v) := 1 + min\{h(e.finish) | e \in G_f, c_f(e) > 0, e.start = v\}$ (на один больше, чем минимальная из высот вершин, куда ведут ненасыщенные ребра из $v$). Заметим, что мы поднимаем на максимальную высоту, на которую можно поднять без нарушения инварианта, и одновременно на минимальную высотую такую, что становится возможно сделать $push$.
\end{definition}

\noindent В качестве алгоритма давайте просто запускать $push$ и $relabel$ в любом порядке, пока не соберется поток.

\begin{note}
    Если у вершины $excess(v) > 0$, то мы всегда можем сделать либо $push$, либо $relabel$ (если нельзя сделать $push$, то можно сделать $relabel$ (по определению)), поэтому если алгоритм завершился, то мы нашли максимальный поток.
\end{note}

\begin{lemma}
    Если $excess(v) > 0$, то в $G_f$ существует путь из $v$ в $s$ по ненасыщенным ребрам.
\end{lemma}

\begin{proof}
    Пусть нет пути, тогда запустим DFS от $v$ по ненасыщенным ребрам и посчитаем сумму всех $excess$ов, тогда их сумма точно больше нуля (как минимум из-за вершины $v$). Внутри этого подграфа все ребра убиваются, т. к. каждое их них учитывается дважды, а значит это суммарная избыточность всего подграфа (всех входящих в него ребер), а значит есть какое-то ребро с ненулевым $excess$ом, которое в него входит. Противоречие, т. к. это значит, что мы могли пройти по обратному ребру и выйти из этого подграфа, тогда DFS должен был по нему пройти.
\end{proof}

\begin{corollary}
    Если $excess(v) > 0$, то $h(v) \leq 2|V| - 1$
\end{corollary}

\begin{proof}
    Рассмотрим путь из $v$ в $s$, пусть его длина равна $k$, тогда в конце (в $s$) будет высота не менее, чем $h(v) - k$, т. к. каждое ребро уменьшает высоту максимум на 1. Но $h(s) = |V|$, поэтому $|V| = h(s) \geq h(v) - k \implies |V| + k \geq h(v)$. Длина пути не может быть больше, чем $|V| - 1$, поэтому $\forall v: excess(v) > 0 \implies |V| + |V| - 1 \geq h(v)$.
\end{proof}

\begin{corollary}
    $\forall v \in V: h(v) \leq 2|V| - 1$
\end{corollary}

\begin{proof}
    Это следует из того, что с помощью $relabel$ мы поднимаем только ненасыщенные вершины
\end{proof}

\begin{proposition}
    Сумма всех $excess(v)$ равна 0
\end{proposition}

\begin{proof}
    Добавив единичку к $excess(v)$ мы ее же вычтем из $excess(s)$
\end{proof}

\subsubsection{Алгоритмы поиска потока за $O(V^3)$}

\begin{theorem}
    Любой алгоритм в данной концепции завершается.
\end{theorem}

\begin{proof}
    Оценим, сколько раз мы можем сделать каждую из операций.
    \begin{enumerate}
        \item Из каждой вершины мы делаем не более, чем $O(V)$ раз $relabel$, поэтому всего их будет сделано $O(V^2)$, но суммарно они работают за $O(VE)$, так как из каждой вершины мы сделаем не более, чем $2|V|$ раз $relabel$, и каждый работает за количество торчащих из нее ребер, если просуммировать, то получим $O(2VE) = O(VE)$.
        \item Если в результате $push$а оказалось, что ребро насытилось (насыщающий $push$), то чтобы повторить $push$ нужно разнасытить ребро, а для этого нужно обе вершины ребра поднять хотя бы на 2 единицы высоты, что можно сделать не более, чем $|V|$ раз, поэтому суммарно таких $push$ей может быть не более, чем $|V| * 2|E|$ (т. к. всего ребер в остаточной сети $2|E|$).
        \item Если в результате $push$а оказалось, что вершина перестала быть избыточной (ненасыщающий $push$), то из этой вершины мы точно не сможем сделать $relabel$. Однако можно сделать еще один $push$ по ребру, которое с ней связано. Чтобы оценить, сколько таких $push$ей можно сделать между двумя $relabel$ами, введем потенциал $\Phi = \sum_{v \in V \setminus \{s, t\}, excess(v) > 0} h(v)$. После ненасыщающего $push$а потенциал уменьшится хотя бы на 1, т. к. мы выкинули из суммы какую-то высоту $h$, но могли добавить какую-то высоту, не превосходящую $h - 1$, если какая-то вершинка стала избыточной. Насыщающий $push$ может добавить к потенциалу высоту конечной вершины ребра, но высоту стартовой может и не убрать, поэтому потенциал увеличится не более, чем на $2|V| - 2$, значит суммарно он увеличится не более, чем на $(2|V| - 2) * 2|V||E|$. Также заметим, что $relabel$ для каждой конкретной вершины увеличит потенциал не более, чем на $2|V| - 1$, поэтому суммарно все $relabel$ы увеличат потенциал не более, чем на $(2|V| - 1) * (|V| - 2)$ (т. к. всего $|V| - 2$ вершин без истока и стока). Заметим, что изначально потенциал равен нулю, меньше нуля он стать не может, и так как всего потенциал может увеличиться на $(2|V| - 2) * 2|V||E| + (2|V| - 1) * (|V| - 2) \leq 4|V|^2(|E| + |V|)$, а каждый ненасыщающий $push$ уменьшает его хотя бы на единицу, то всего их не более, чем $4|V|^2(|E| + |V|) = O(V^2E)$.
    \end{enumerate}
\end{proof}

\begin{algorithm}[Первый алгоритм (первая идея, втупую)]
    Поддерживаем очередь всех вершин с ненулевым $excess$ом. Для этого после $push$а проверяем, обнулился ли у вершины $excess$. Он может обнулиться только в той вершине, из которой выходит ребро для которого делается $push$ (в другой вершине ребра он мог наоборот стать ненулевым, что означает, что ее нет в очереди и ее нужно туда добавить). Теперь можно просто перебирать каждое ребро у каждой вершинки, и делать либо $push$, если можно, либо $relabel$, если нельзя, и тогда уже получился алгоритм за $O(V^3E)$. \\
    Теперь будем поддерживать двусвязанный список ребер, по которым можно сделать $push$. Операция $push$ может поменять только $2 = O(1)$ ребер, а $relabel$ мы будем делать простым проходом по всем ребрам (включая обратные, суммарно за $O(VE)$), во время которого мы можем нужным образом изменить наш список. Теперь будем с помощью очереди находить за $O(1)$ избыточную вершину, а потом с помощью списка за $O(1)$ находить ребро, по которому можно сделать $push$, а если таких нет, то делаем $relabel$. Теперь алгоритм работает за $O(V^2E)$. \\
\end{algorithm}

\begin{algorithm}[Первый алгоритм (вторая идея, с сортировкой по высоте)]
    Предположим, что мы нашли избыточную вершину, пробегаемся по ее ребрам и сделали где-то $push$. Заметим, что пробегаться еще раз по этим же ребрам до ближайшего $relabel$а не имеет смысла -- т. к. если мы не могли сделать по ним $push$, то и не сможем. Максимум, что может произойти с ребром -- это разнасыщение, но тогда ребро ввело не вниз, а вверх, и до $relabel$а это не поменяется. Тогда давайте введем $it[v]$ -- итератор на текущее ребро в списке ребер $v$, а также новую операцию.

    \begin{definition}[$discharge(v \in V \setminus \{s, t\})$]
        Ее цель -- обнулить избыточность вершины. \\
        Требования:
        \begin{enumerate}
            \item $excess(v) > 0$
        \end{enumerate}
        Действие: 
        \begin{lstlisting}
    while (excess(v) > 0) {
        if (it[v].valid()) {
            if (mayPush(*it[v])) {
                push(*it[v]);
            } else {
                it[v].goNext();
            }
        } else {
            relabel(v);
            it[v] = begin(v);
        }
    }
        \end{lstlisting}
        То есть просто перебираем все ребра и делаем $push$ пока можно, а когда ребра закончились сделаем $relabel$ и продолжим перебирать ребра с начала списка до тех пор, пока вершина избыточна.
    \end{definition}

    Теперь давайте просто хранить список избыточных вершин, и пока он не пустой будем брать любую и делать с ней $discharge$. Заметим, что ненасыщающих $push$ей у нас $O(V^2E)$, а каждое ребро для которого мы не делаем $push$ мы просматриваем $O(V)$ раз (когда делаем ненасыщающий избыточный $push$, заканчивая $discharge$ и возвращаясь к этому же ребру при следующем вызове), поэтому суммарно время работы будет $O(VE) + O(V^2E) = O(V^2E)$.

    Для ускорения давайте отсортируем все вершины в порядке неубывания высот (за $O(V)$ сортировкой подсчетом), и будем просто делать $discharge$ у каждой вершины по порядку этой сортировки, а потом повторим все заново, если остались избыточные вершины. Таким образом алгоритм будет состоять из трех частей: сортировки, ненасыщающие $push$ы в $discharge$ и все остальное в $discharge$. По доказанному выше третий пункт работает суммарно за $O(VE)$. Теперь заметим, что на каждом запуске $discharge$ мы сделаем максимум одно ненасыщающее проталкивание (т. к. оно будет избыточным, после чего цикл остановится). На каждой фазе мы сделаем сортировку за $O(V)$ и не более чем $O(V)$ раз $discharge$ (кроме третьего пункта, который мы оценили отдельно). Рассмотрим, как меняется избыточность у вершин во время каждой фазы. Избыточность постепенно обнуляется у вершин и опускается к вершинам с меньшей высотой. Тогда либо в какой-то момент произошел $relabel$ и какая-то вершина поднялась выше, либо его никогда не было и избыточность обнулилась у всех вершин (кроме истока и стока), а это значит, что алгоритм завершился. Получается, что все фазы кроме последней содержат в себе хотя бы один $relabel$, но так как их всего может быть суммарно $O(V^2)$, то всего фаз будет $O(V^2)$, а время работы алгоритма $O(V^2) * (O(V) + O(V)) + O(VE) = O(V^3 + VE) = O(V^3)$.
\end{algorithm}

\begin{algorithm}[Алгоритм ``поднять в начало'']
    Сделаем список, куда положим все вершины в рандомном порядке. Будем идти по ним и делать на каждой $discharge$, а если в процессе какого-то $discharge$ мы сделали $relabel$, то переместим эту вершину в начало списка и начнем перебирать вершины с его начала. Делаем так до тех пор, пока мы не пройдем полностью весь список.

    \begin{lemma}
        Пусть в процессе есть ребро $(u, v)$, по которому можно сделать $push$. Тогда в списке позиция $u$ меньше, чем позиция $v$
    \end{lemma}

    \begin{proof}
        Пусть перед началом очередной фазы данное утверждение верно. Тогда пока мы не сделали $relabel$ данный инвариант будет сохранятся, т. к. в результате $push$а новое ``хорошее'' ребро не появится. Теперь пусть мы сделали $relabel$ и переместили вершину в начало списка. В нее не могли вести хорошие ребра, т. к. мы увеличили ее высоту (и если в нее все еще ведет какое-то ребро, то разность высот у ребра была более, чем один, что невозможно по определению). А исходящие ребра останутся хорошими, т. к. вершина теперь в начале списка.
    \end{proof}
\end{algorithm}

\begin{algorithm}[Третий алгоритм (с очередью)]
    Рассмотрим следующий код:
    \begin{lstlisting}
        Q = {};
        for v in V \ {s, t}
            if (excess(v) > 0)
                Q.push(v);
        while (!Q.empty()) {
            v = Q.front();
            v.pop();
            discharge(v);
        }

        // in push(e):
        .
        .
        .
        excess(e.start) -= delta_f;
        if (excess(e.finish) == 0 && e.finish not in {s, t})
            Q.pop(e.finish);
        excess(e.finish) += delta_f;
        .
        .
        .
    \end{lstlisting}

    То есть заведем очередь и будем поддерживать в ней все избыточные вершины.
\end{algorithm}

\begin{proposition}
    Данный алгоритм работает за $O(V^3)$
\end{proposition}

\begin{proof}
    Введем потенциал $\Phi = \max_{v \in V \setminus \{s, t\}, excess(v) > 0} h(v)$ и понятие ``фазы'': вершины нулевой фазы это те, которые лежали в очереди в начале алгоритма, $i$-ой фазы -- те, который были добавлены в очередь во время обработки $i-1$-ой фазы. Пусть фазы первого типа это те, во время которых произошел хотя бы один $relabel$, а второго типа все остальные. Фаз первого типа $O(V^2)$, а во время фазы второго типа потенциал уменьшился, так как к моменту начала фазы в ней были те и только те вершины, у которых есть избыток, и вызвав $discharge$ от вершин с самой большой высотой они перестанут быть избыточными, и, соответственно, перестанут учитываться в потенциале. Заметим, что потенциал увеличивается суммарно на $O(V^2)$ (т. к. после каждого $relabel$а он увеличивается максимум на 1, а всего их $O(V^2)$), а значит и фаз второго типа $O(V^2)$, а значит весь алгоритм работает за $O(V) * (O(V^2) + O(V^2)) = O(V^3)$.
\end{proof}

\begin{note}
    Данный алгоритм -- это по сути тоже самое, что и первый алгоритм (где была сортировка вершин по неубыванию), так как нам важно только то, что мы выписали все избыточные вершины и применили ко всем ним $discharge$ (оказывается, что на самом деле не важно, в каком порядке). Это замечание приводит нас к четвертому алгоритму.
\end{note}

\begin{algorithm}[Четвертый алгоритм]
    Реализация:
    \begin{lstlisting}
        while (someone_has_excess()):
            for v in V \ {s, t}:
                discharge(v);
    \end{lstlisting}
    Из предыдущего алгоритма следует, что и тут будет выполнено $O(V^2)$ вызовов $discharge$ (т. к. если у вершинки нулевой избыток, то мы сразу же выйдем из $discharge$), что дает итоговую асимптотику $O(V^3)$
\end{algorithm}

\subsubsection{Алгоритм за $O(V^3)$ в концепции блокирующих потоков}

\begin{reminder}
    \begin{definition}
        Пусть $G = (V, E, c, s, t)$ -- сеть. Пусть $v \in V \setminus \{s, t\}$. Тогда:
        \begin{itemize}
            \item Входящий потенциал $p_{in}(v) \equiv p_{g, in}(v) = \sum_{e \in E, e.finish = v}c(e)$
            \item Исходящий потенциал $p_{out}(v) \equiv p_{g, out}(v) = \sum_{e \in E, e.start = v}c(e)$
            \item Потенциал $p(v) \equiv p_{g}(v) = min(p_{in}(v), p_{out}(v))$ ($p(s) = p_{out}(s), p(t) = p_{in}(t)$)
            \item Потенциал сети $P \equiv P_{g} = \sum_{v \in V \setminus \{s, t\}}p(v)$
        \end{itemize}
    \end{definition}
\end{reminder}

\begin{algorithm}[Малхотры-Кумара-Махешвари]
    Пусть мы ищем блокирующий поток, рассмотрим слоистую сеть. Давайте считать потенциалы в текущий момент времени. Возьмем вершину $v$ с минимальным потенциалом $p(v) = z$. Теперь давайте пустим поток величины $z$, проходящий через $v$. Для этого возьмем любые исходящие из $v$ ребра и пустим по ним суммарно $z$ потока, который можно как-нибудь дальше жадно протолкнуть т. к. потенциал каждой вершины не меньше, чем $z$. Аналогично протолкнем поток назад по обратным ребрам (чтобы пустить $z$ потока из $s$ в $v$). После этого выкинем вершину $v$ и все торчащие из нее ребра. Проталкиваем поток так же, как в Динице, поэтому каждое проталкивание работает за $O(V + E_{deleted}) = O(V^2 + E)$, всего проталкиваний сделаем $O(V)$ (т. к. после каждого удаляем одну вершину), поэтому суммарное время работы $O(V * (V^2 + E)) = O(V^3)$.
\end{algorithm}

\begin{problem}[Про любовь]
    Есть $n$ мужчин и женщин, которые хотят друг с другом пожениться. Люди взрослые, поэтому каждый может жениться на ком угодно (противоположного пола), но у каждого человека есть свой список всех людей противоположного пола отсортированный в порядке личной привлекательности. Введем понятие измены -- мужчина $A$ изменяет с девушкой $B$, если для $A$ привлекательность $B$ больше, чем привлекательность его жены, а для $B$ привлекательность $A$ больше, чем ее мужа. Необходимо поженить мужчин и женщин так, чтобы не было потенциальных измен (это всегда возможно).
\end{problem}









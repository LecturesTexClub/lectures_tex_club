\section{Потоки}

\subsection{Введение в потоки}

\subsubsection{Основные определения}

\begin{definition}
    Сеть -- это ориентированный граф, в котором:
    \begin{enumerate}
        \item Каждое ребро $(u, v) \in E$ имеет неотрицательную пропускную способность $c(u,v) > 0$
        \item Если $(u,v) \notin E$, то $c(u, v) = 0$, а также будем считать, что петель и кратных ребер нет (на самом деле они могут быть, т. к. пропускную способность кратных ребер можно сложить, а петли игнорировать)
        \item Выделены две различные вершины -- исток (source, s) и сток (sink, t)
    \end{enumerate}
\end{definition}

\begin{example}
    Карта трубопровода
    \begin{itemize}
        \item Вершины -- пункты перераспределения воды
        \item Ребра -- трубы, соединяющие вершины
        \item Пропускная способность -- количество воды, которое может течь по трубе за единицу времени
    \end{itemize}
\end{example} 

\noindent Основная задача: какое же максимальное количество воды может перетекать из исток в сток за единицу времени?

\begin{definition}
    Поток в сети $G = (V, E)$ -- функция $f: V \times V \rightarrow \mathbb{R}$, удовлетворяющая следующим свойствам:
    \begin{enumerate}
        \item Антисимметричность ($f(u, v) = -f(v, u)$)
        \item Ограничение потока ($f(u, v) \leq c(u, v)$)
        \item Сохранение потока ($\forall u \in V \setminus \{s, t\}: \Sigma \{f(u, v) | v \in V\} = 0$)
    \end{enumerate}
\end{definition}

\begin{definition}
    Второе (более ``программистское'') определение сети:
    \begin{itemize}
        \item $G = (V, E, c, s, t)$ -- это сеть
        \item $C: e \rightarrow \mathbb{R}_{\geq 0}$ -- пропускная способность
        \item $s \in V$ -- исток
        \item $t \in V \setminus \{s\}$ -- сток
    \end{itemize}
\end{definition}

\noindent Пусть $G = (V, E, c, s, t)$ -- сеть, тогда
\begin{definition}
    Поток -- это функция $f: E \rightarrow \mathbb{R}_{\geq 0}$, удовлетворяющая следующим свойствам:
    \begin{enumerate}
        \item $\forall e \in E: f(e) \leq c(e)$
        \item $\forall u \in V \setminus \{s, t\}: \sum_{e \in E: e.finish = u} f(e) = \sum_{e \in E: e.start = u} f(e)$
    \end{enumerate}
\end{definition}

\begin{definition}
    Величина потока -- это одно из следующих определений:
    \begin{enumerate}
        \item $|f| = \Sigma \{f(s, u) | u \in V\}$ (``сколько воды вытекает из истока'')
        \item $|f| = \Sigma \{f(u, t) | u \in V\}$ (``сколько воды втекает в сток'')
    \end{enumerate}
\end{definition}


\begin{lemma}
    Определения 1 и 2 эквивалентны
\end{lemma}

\begin{proof}
    Заметим, что по свойству 3: $0 = \Sigma_{v \in V, u \in V \setminus \{s, t\}} f(v, u) = \Sigma_{v, u \in V \setminus \{s, t\}} f(v, u) + \Sigma_{u \in V \setminus \{s, t\}} f(s, u) + \Sigma_{u \in V \setminus \{s, t\}} f(t, u)$ \\
    Далее, по свойству 1, предыдущее выражение равняется $\Sigma_{u \in V \setminus \{s, t\}} f(s, u) - \Sigma_{u \in V \setminus \{s, t\}} f(u, t)$ \\
    Следовательно, $\Sigma_{u \in V} f(s, u) = \Sigma_{u \in V} f(u, t)$
    % Заметим, что по свойству 3: $0 = \Sigma \{ \Sigma \{f(v, u) | u \in V \setminus \{s, t\}\} | v \in V\} = \Sigma \{ \Sigma \{f(v, u) | u \in V \setminus \{s, t\}\} | v \in V \setminus \{s, t\}\} + \Sigma \{ f(s, u) | u \in V \setminus \{s, t\}\} + \Sigma \{ f(t, u) | u \in V \setminus \{s, t\}\}$.
    % Далее, по свойству 1: $\Sigma \{ \Sigma \{f(v, u) | u \in V \setminus \{s, t\}\} | v \in V \setminus \{s, t\}\} + \Sigma \{ f(s, u) | u \in V \setminus \{s, t\}\} + \Sigma \{ f(t, u) | u \in V \setminus \{s, t\}\} = \Sigma \{ f(s, u) | u \in V \setminus \{s, t\}\} - \Sigma \{f(u, t) | u \in V \setminus \{s, t\}\}$.
    % Следовательно, $\Sigma \{ f(s, u) | u \in V\} = \Sigma \{f(u, t) | u \in V\}$
\end{proof}

\begin{definition}
    Аналогичное определение величины потока (для второго определения сети и потока): $|f| = |f|_t = |f|_s = \sum_{e \in E | e.start = s} f(e) = \sum_{e \in E | e.finish = s} f(e)$
\end{definition}

\begin{exercise}
    Провернуть такое же доказательство леммы, но с другим определением потока и сети
\end{exercise}

\subsubsection{Остаточная сеть}

\noindent Пусть в сети $G$ имеется поток $f$, и пусть $u, v \in V$
\begin{definition}
    Остаточная пропускная способность: $c_f(u, v) = c(u, v) - f(u, v)$
\end{definition}

\noindent Пусть $G = (V, E, c, s, t)$ -- сеть, а $f$ -- поток в ней, тогда
\begin{definition}
    Остаточная сеть $g_f$ -- это сеть $(V, E_f, c_f, s, t)$, где
    \begin{itemize}
        \item $E_f = \{E \bigcup revE\}$
        \item $rev(\{u, v\}) = (\{v, u\})$
        \item $rev(E) = \{rev(e) | e \in E\}$
        \item $c_f(e) = \begin{cases}
            c(e) - f(e), e \in E \\
            f(e'), e = rev(e'), e' \in E
        \end{cases}$
    \end{itemize}
\end{definition}

\noindent Пусть $G = (V, E)$ -- сеть, и $f$ -- поток в ней. Пусть $f'$ -- поток в остаточной сети $G_f$. 
\begin{definition}
    Увеличение потока в $f$ на $f'$ -- функция $(f \uparrow f'): V \times V \rightarrow \mathbb{R}$, определяемая следующим образом:
    $(f \uparrow f')(u, v) = f(u, v) + f'(u, v), (u, v) \in E$
\end{definition}

\begin{lemma}
    $(f \uparrow f')$ -- поток в сети $G$, причем $|(f \uparrow f')| = |f| + |f'|$.
\end{lemma}

\begin{proof}
    Для доказательства леммы нужно доказать следующие утвреждения:
    \begin{enumerate}
        \item $\forall u, v \in V: (f \uparrow f')(u, v) \leq c(u, v)$
        \item $\forall u \in V \setminus \{s, t\}: \Sigma \{(f \uparrow f')(u, v) | v \in V\} = 0$
        \item $|(f \uparrow f')| = |f| + |f'|$
    \end{enumerate}
    Единственный нетривиальный пункт -- первый, доказательство: $(f \uparrow f')(u, v) = f(u, v) + f'(u, v) \leq f(u, v) + c(u, v) - f(u, v) = c(u,v)$, ЧТД.
\end{proof}

\begin{definition}
    Будем говорить, что в сети есть ребро из $u$ в $v$ если $c(u, v) > 0$
\end{definition}
\begin{definition}
    Существует путь из $u$ в $v$, если существует последовательность $u = v_1, v_2, \ldots, v_k = v$, т. ч. $\forall i \in [1, k): c_f(v_i, v_{i+1}) > 0$
\end{definition}
\begin{definition}
    Назовем ребро насыщенным, если поток по нему максимален 
\end{definition}
\begin{definition}
    Увеличивающий путь в сети -- путь из $s$ в $t$ по ненасыщенным ребрам
\end{definition}

\noindent Лемма 1.2 говорит, что если в остаточной сети есть увеличивающий путь, то поток $f$ можно увеличить. Но является ли такое условие необходимым? Найдем ли мы максимальный поток, если будем просто пропускать поток в остаточной сети?

\subsubsection{Разрезы}

\begin{definition}
    Разрез $(S, T)$ в сети $G = (V, E)$ -- это разбиение множества вершин на два непустых множества $S$ и $T$, т. ч. $s \in S$, $t \in T$
\end{definition}
\begin{definition}
    Пропускной способностью разреза $c(S, T)$ назовем число $\Sigma \{c(u, v) | u \in S, v \in T\}$
\end{definition}
\begin{definition}
    Минимальным разрезом назовем разрез, пропускная способность которого минимальна
\end{definition}
\begin{definition}
    Пусть $f$ -- поток в сети $G$. Чистым потоком $f(S, T)$ через разрез $(S, T)$ назовем число $\Sigma \{f(u, v) | u \in S, v \in T\}$ (для второго определения потока нужно еще вычесть потоки в другую сторону)
\end{definition}

\begin{lemma}
    Для любого разреза $(S, T): f(S, T) = |f|$
\end{lemma}
\begin{proof}
    По свойствам антисимметричности и сохранения потока: \\
    $|f| = \sum_{v \in S} \sum_{u \in V} f(v, u) = \sum_{v \in S} \sum_{u \in T} f(u, v) = f(S, T)$ \\
    $|f| = f(S, T) \leq c(S, T)$
\end{proof}

\begin{lemma}
    $|f|$ не превосходит пропускной способности минимального разреза.
\end{lemma}
\begin{proof}
    Для любого разреза $(S, T): |f| = \Sigma \{ f(u, v) | u \in S, v \in T\} \leq \Sigma \{c(u, v) | u \in S, v \in T\} = c(S, T)$, следовательно $|f|$ не превосходит минимальной из пропускных способнростей разрезов, ЧТД.
\end{proof}

\noindent Всего есть $2^{|V| - 2}$ разрезов, значит, максимальный поток не превосходит минимальный из них. То есть всегда существует максимальный поток, но всегда ли он достигается?

\begin{theorem}[Форда-Фалкерсона]
    Пусть $G = (V, E)$ -- сеть, а $f$ -- поток этой сети. Тогда эквивалентны следующие 3 утвреждения:
    \begin{enumerate}
        \item $f$ -- максимальный поток
        \item Остаточная сеть $G_f$ не содержит увеличивающих путей
        \item $|f| = c(S, T)$ для некоторого разреза сети $G$.
    \end{enumerate}
\end{theorem}

\begin{proof}
    $1 \implies 2$: очевидно из рассмотренного раннее \\ 
    $3 \implies 1$: прямое следствие леммы 1.4 \\
    Осталось доказать $2 \implies 3$. \\
    Пусть $G_f$ - остаточная сеть без увеличивающих путей, $S = \{v \in V | $ существует путь от $s$ до $v\}$, $T = V \setminus S$. По определению множества $S$:
    \begin{enumerate}
        \item $t \notin S$
        \item $\forall u \in S, v \in T: f(u, v) = c(u, v)$
    \end{enumerate}
    Следовательно, $(S, T)$ -- разрез, причем $|f| = f(S, T) = c(S, T)$, ЧТД.
\end{proof}

\noindent Метод Форда-Фалкерсона для $(G, s, t)$:
\begin{enumerate}
    \item Для каждого ребра $(u, v) \in G.E: (u, v).f = 0$
    \item Пока существует путь $p$ из $s$ в $t$ в остаточной сети $G_f$:
    \begin{itemize} 
        \item $c_f(p) = min\{c(u, v) | (u, v) \in p\}$
        \item $\forall (u, v) \in p: (u, v).f += c_f(p), (v, u).f -= c_f(p)$
    \end{itemize}
\end{enumerate}
\noindent Это именно метод, а не алгоритм, т. к. не указано, как именно проверять существование пути.

\subsubsection{Паросочетания}

\begin{definition}
    Двудольный граф -- граф, вершины которого можно разбить на два множества так, чтобы ребра соединяли только вершины из разных множеств.
\end{definition}

\begin{definition}
    Паросочетание -- множество ребер, в котором все вершины у ребер различны
\end{definition}

\begin{problem}
    Как найти максимальное паросочетание в двудольном графе?
\end{problem}

\begin{solution}
    Все ребра ориентируем на правую долю и пусть их пропускная способность равна единице. Из истока $s$ проведем ребра во все вершины левой доли, а из всех вершин правой доли проведем ребра в сток $t$. После этого просто найдем максимальный поток.
\end{solution}

\begin{proposition}
    Размер максимального паросочетания равен размеру максимального потока
\end{proposition}
\begin{proof}
    Как вообще выглядят пути? Потоки не пересекаются по ребрам, поэтому каждая вершинка будет лежать максимум на одном пути из истока в сток, то есть на одном ребре исходного графа. ЧТД. Время работы: $O(VE)$.
\end{proof}

\begin{proposition}
    Алгоритм Куна -- это оптимизированная версия этого алгоритма
\end{proposition}

\begin{proof}
    Рассмотрим сам алгоритм куна. Давайте ориентируем ребра из паросочетания справа налево. Чтобы найти увеличивающий путь нужно пройти по ребру из $s$, пройти по ребру не из паросочетания, потом по ребру из паросочетания назад, по ребру не из паросочетания вперед, по ребру из паросочетания назад, повторить нужное количество раз, потом пройти направо по ребру не из паросочетания, а потом по ребру в сток, и вот мы нашли увеличивающий путь: давайте инвертируем все ребра на пути, таким образом увеличив размер паросочетания. Следующий шаг оптимизации -- можно не хранить исток и сток и все связанные с ними ребра, а чтобы инвертировать ребра можно для вершин правой доли хранить массив соседей из левой доли среди ребер из паросочетания, а искать увеличивающий путь можно дфсом
\end{proof}

\noindent Рассмотрим код алгоритма Куна:
\begin{lstlisting}
    dfs(int u) {
        if (!used[u]) return false;
        used[u] = 1
        for (u, v in E) {
            if (pr[v] < 0 || dfs(pr[v])) {
                pr[v] = u;
                return true;
            }
        }
        return false;
    }
\end{lstlisting}

\begin{lstlisting}
    int findHatching() {
        int ans = 0;
        bool isOK = true;
        while (isOK) {
            isOK = false;
            for (u in L) {
                if (!(u in matching)) {
                    used.assign(|L|, 0);
                    if (dfs(u)) {
                        ++ans;
                        isOK = true;
                    }
                }
            }
        }
        return ans;
    }
\end{lstlisting}

\noindent Но стандартный Кун обычно пишется по-другому:
\begin{lstlisting}
    int Kuhn() {
        for (u in L) {
            used.assign(|L|, 0);
            if (dfs(u)) {
                ++ans;
            }
        }
        return ans;
    }
\end{lstlisting}

\noindent Но эта реализация работает за честное $O(VE)$, а не за $E$, умноженное на размер паросочетения. Поможет такая оптимизация:
\begin{lstlisting}
    int Kuhn() {
        used.assign(|L|, 0);
        for (u in L) {
            if (dfs(u)) {
                ++ans;
                used.assign(|L|, 0);
            }
        }
        return ans;
    }
\end{lstlisting}

\noindent Но почему же алгоритм Куна вообще работает? Для этого докажем лемму из теории потоков.
\begin{lemma}
    Пусть $G$ -- сеть, в которой мы ищем поток методом Форда-Фалкерсона. Пусть перед какой-то итерацией из некоторой вершины $v$ нельзя дойти до $t$ в $G_{fcur}$ по ненасыщенным ребрам. Тогда после этой итерации пути из этой вершины $v$ в $t$ (по ненасыщенным ребрам) появиться не могло.
\end{lemma}

\begin{proof}
    До какой-то итерации пути не было, тогда пусть после этой итерации он резко появился. Это значит, что на только что появившемся пути из $v$ в $t$ появились какие-то новые ненасыщенные ребра, которых раньше не было (остальные ребра на пути уже были ненасыщенными). Если ребра стали ненасыщенными, значит в какой-то итерации алгоритма мы нашли путь, который содержит эти ребра и пустили по ним отрицательный поток. Это значит, что до этой итерации мы могли пойти от $v$ по ненасыщенным ребрам до первого ребра, которое было насыщенным, но перестало после данной итерации, и продолжить идти по пути, который нашла данная итерация. Противоречие -- путь из $v$ в $t$ на самом деле был, а мы предполагали, что его не было.
\end{proof}

\noindent Из этой леммы явным образом следует корректность работы алгоритма Куна.
\begin{problem}
    Дано $10^6$ кубиков, на каждом кубике на каждой грани написана буква, нужно узнать, можно ли собрать из данных кубиков данное слово.
\end{problem}
\begin{solution}
    Тупое решение: все кубики будут в левой доли, все буквы из искомого слова по порядку в правой доли. Найдем максимальное паросочетание, и если его размер равен размеру слова, то мы победили. \\
    Более оптимальное решение: все кубики будут в левой доли, в правой доли все возможные буквы из алфавита, а из них ребра в сток с пропускной способностью, равной количеству вхождений этой буквы в искомое слово. Найдем максимальный поток и сравним с длиной слова. Интересный факт: слева будет $26^6$ вершин, справа 26, получается, что задача решается за $O(1)$ (но на самом деле пока нет, т. к. мы пока не изучили алгоритмов нахождения потока, которые не зависят от пропускной способности)
\end{solution}

\begin{problem}
    У Пети много монет, у каждой один из 100 типов. Каких-то типов у Пети больше, каких-то меньше. Он может обмениваться монетками с другими один к одному, но оппонент соглашается на обмен, если монетки Пети у него нет, а ту, которую просит Петя, у него в избытке. Какое максимальное количество различных монет Петя может иметь после серии обменов с разными людьми? (известны все люди и кол-ва их монеток)
\end{problem}

\begin{problem}
    У вас есть команда из $n$ человек, вам нужно каждому дать работу программиста или тестировщика. Некоторые люди не хотят быть на определенной работе. Если $i$-й человек не хочет работать программистом, но работает им, то он добавляет $a_i$ единиц расстройства в общий счетчик грусти. Аналогично с работой тестировщиком и $b_i$. Некоторые пары людей умеют дружить -- если $i$-й и $j$-й человек дружат, но работают на разных работах, то к грусти добавляется $c_{i, j}$. А еще бывает ситуация, когда $i$-й человек не хочет, чтобы одновременно он был программистом, а $j$-й человек тестировщиком, и в таком случае к грусти добавляется $d_{i, j}$. Необходимо найти разбиение людей на работы такое, что суммарная грусть будет минимальна.
\end{problem}

\begin{solution}
    Найдем такой разрез графа, что в доле $S$ будут лежать программисты, а в $T$ -- тестировщики. Если $i$-й человек не хочет быть программистом, то проведем ребро из истока в $i$-ю вершину, а если тестировщиком -- то из $i$-й в сток с пропускной способностью $a_i$ или $b_i$ соответственно. В случае дружбы проведем между $i$-й и $j$-й вершиной ориентированные ребра в обе стороны с пропускной способностью $c_{i, j}$, а для $d_{i, j}$ проведем ребро $(i, j)$. Каждое ребро - добавляемая грусть в случае плохого распределения на работы для кого-то из людей. Таким образом, найдя минимальный разрез, мы найдем разбиение на работы с минимальной суммарной грустью. Чтобы найти минимальный разрез достаточно найти максимальный поток. Если нужно конкретное разбиение на профессии, то заметим, что в множество $S$ входят все вершины, до которых существует путь из $s$.
\end{solution}

\begin{definition}
    Совершенное паросочетание -- паросочетание, проходящее по всем вершинам.
\end{definition}

\begin{problem}
    Есть $n$ мальчиков и девочек, им надо разбиться на пары на бал, но мальчики могут приглашать только тех девочек, которые им нравятся. Нужно узнать, можно ли сделать так, чтобы каждый человек стоял с кем-то в паре.
\end{problem}
\begin{solution}
    Для каждого мальчика $u$ возьмем множество $N(u)$ -- множество девочек, которые ему нравятся. Тогда нужно, чтобы, как минимум, для любого подмножества мальчиков размера $k$ суммарное кол-во девочек, которые им нравятся, равнялось хотя бы $k$ (иначе как минимум это подмножество мальчиков не выйдет разбить на пары). Оказывается, что это не только необходимое условие, но и достаточное.
\end{solution}

\begin{lemma}[Холла]
    Совершенное паросочетание существует тогда и только тогда, когда $\forall U \subset L: |N(U)| \geq |U|$
\end{lemma}
\begin{proof}
    Слева направо очевидно. Справа налево: проведем ребра из истока во все вершины левой доли и из всех вершин правой доли в сток. Далее возьмем любое подмножество из $k$ вершин из левой доли и проведем из каждой вершины $u$ из этого подмножества в $N(u)$. Рассмотрим минимальный разрез -- мальчиков со стороны истока назовем $L_S$, со стороны стока $L_T$, аналогично с девочками: получим множества $R_S$ и $R_T$. Далее заметим следующее: $c(S, T) = |L_T| + |R_S| + c(L_S, R_T) = |L_T| + |R_S| + |N(L_S) \bigcap R_T| = |L_T| + |R_S| + |N(L_S)| - |N(L_S) \bigcap R_S| \geq |L_T| + |N(L_S)| \geq |L_T| + |L_S| = |L|$. Из этого явно следует истинность леммы, ЧТД.
\end{proof}







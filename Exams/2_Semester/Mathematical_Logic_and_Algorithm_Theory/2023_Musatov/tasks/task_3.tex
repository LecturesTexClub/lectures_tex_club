\section{Вопросы из билетов}

\subsection{Моделирование машины Тьюринга с несколькими лентами на машине Тьюринга с одной лентой.}
\textbf{Машина Тьюринга (МТ) состоит из:} \par
– бесконечной в две стороны ленты, в ячейках которой могут быть записаны символы
алфавита A (некоторого конечного множества);\par
– головки, которая может двигаться вдоль ленты, обозревая в каждый данный момент
времени одну из ячеек;\par
– оперативной памяти, которая имеет конечный размер (другими словами, состояние оперативной памяти — это элемент некоторого конечного множества, которое называется
множеством состояний МТ Q);\par
– таблицы переходов (или программы), которая задаёт функцию.

У \textbf{многоленточных} машин не одна лента, а несколько (фиксированное число для конкретной машины). На каждой ленте есть своя головка. За такт работы головки могут перемещаться по всем лентам. Действие на такте работы зависит как от состояния машины, так и от всего набора символов, которые видят головки машины на всех лентах.\par
Чтобы задать машину с h лентами, нужно указать:\par
– алфавит A, в котором выделен пустой символ $\Lambda$;\par
– множество состояний Q, в котором выделено начальное состояние $q_0$; \par
– таблицу переходов, которая теперь является функцией вида
$\delta : A^h \times Q \rightarrow A^h \times Q \times \{-1, 0, +1\}^h$
(первый аргумент — символы, которые машина видит на ленте; последний — команды
движения для головок на каждой ленте); \par
– выделить среди лент ленту входа и ленту результата (возможно, что это одна и та же
лента).

h-МТ M \textbf{вычисляет} функцию $f : B^* \rightarrow B^*$
(где B — подмножество алфавита машины, не содержащее пустого символа), если для каждого w из области определения функции f результат работы M равен f(w), а для каждого w не из области определения f машина M не останавливается на входе w. \\
\\
\emph{Любая функция, вычислимая на многоленточной МТ, вычислима и на одноленточной машине.} \par
Докажем, построив для произвольной h-МТ искомую одноленточную. Если описывать конфигурации h-МТ $M_h$ в виде матрицы конфигурации размера $h \times N$, то каждый столбец такой матрицы может находиться в конечном числе состояний: не более $(A \cdot (Q + 1))^h$, где A — размер алфавита, а Q — количество состояний.

Моделирующая машина $M_1$ использует расширенный алфавит из $A + (A \cdot (Q + 1))^h$
(пустой символ и символы, отвечающие различным столбцам матрицы конфигурации). Она поддерживает описание матрицы конфигурации машины $M_h$ в этом алфавите и изменяет его, моделируя
работу $M_h$ по тактам.

Поскольку действия $M_h$ на каждом такте работы зависят от её состояния и символов под
головками на каждой ленте, машина $M_1$ поддерживает также и эту информацию, записывая
её в «оперативную память». Т.е. состояния $M_1$ представляются парами («управляющее состояние», «оперативная память»).

Такт работы машины $M_h$ моделируется машиной $M_1$ в два этапа. На первом этапе машина $M_1$ просматривает все непустые ячейки на своей ленте слева направо и определяет, какие символы расположены под текущими положениями головок машины $M_h$.

На втором этапе $M_1$ изменяет содержимое своей ленты в соответствии с таблицей переходов
машины $M_h$. \\
\\

Более детальное описание устройства $M_1$: 

- Алфавит машины $M_1$ — $A' = A \cup (A \times (Q \cup \Lambda))^h$;

- Пустой символ тот же, что и у моделируемой машины $M_h$;

- Машина $M_1$ является последовательным соединением трёх машин: $M_s$, $M_w$, $M_f$.
\\
\\
1. $M_s$. Первая машина $M_s$ подготавливает содержимое ленты к двухэтапному моделированию тактов работы машины $M_h$. Машина $M_s$ просматривает ячейки входного слова. Первый символ $a_1$
она заменяет на$ ((a_1, q_0),(\Lambda, q_0), . . . ,(\Lambda, q_0))$ (это первый столбец матрицы начальной конфигурации $M_h$), а каждый последующий символ входа a на $((a,\Lambda),(\Lambda,\Lambda), . . . ,(\Lambda,\Lambda))$ (это остальные
столбцы матрицы начальной конфигурации — напомним, что в начальной конфигурации все
ленты, кроме входной, пусты). Обнаружив пустой символ $\Lambda$, машина $M_s$ возвращается в крайнее левое положение и останавливается.
\\
\\
2. $M_w$. Вторая машина $M_w$ моделирует такты работы $M_h$ описанным выше способом. Она проходит непустые ячейки ленты два раза. При движении слева направо машина $M_w$ «запоминает»
символы под головками машины $M_h$ по следующему правилу: если в очередном столбце матрицы конфигурации машины $M_h$ на i-й позиции находится пара $(a, q), q \in Q$, то i-я головка
расположена над символом a. К концу первого прохода в оперативной памяти $M_w$ содержится полная информация о символах под головками и состоянии $M_h$, что однозначно определяет строчку таблицы переходов $M_h$, которую нужно применить на данном такте. Если такой строчки нет, то $M_w$ заканчивает работу.

На втором проходе найденная строчка таблицы переходов $M_h$ используется для обновления
матрицы конфигурации. Информация о символах на лентах $M_h$ обновляется по следующему
правилу: если в очередном столбце матрицы конфигурации машины $M_h$ на i-й позиции находится пара $(a, q), q \in Q$, то столбец меняется так, чтобы в этой позиции было написана пара
$(a', q)$, где $a'$ — символ, который $M_h$ записывает на i-ую ленту. Те пары в столбце, которые
соответствуют ячейкам, над которыми нет головки, не изменяются.


Кроме того, нужно обновить информацию о положениях головок соответственно текущей
команде движения. Для этого машина $M_w$ переписывает вторые компоненты пар, из которых
состоит столбец матрицы конфигурации $M_h$ (т.е. текущий столбец матрицы). Движение по
каждой ленте может быть как влево, так и вправо. Поэтому для выполнения этого действия
$M_w$ перемещается из текущего положения на шаг вправо, записывая в этот столбец новые
положения головок, и на шаг влево, выполняя аналогичное действие. При выполнении этих
действий машина $M_w$ может выйти за пределы рабочей зоны (матрицы конфигурации). Тогда
она оказывается над пустым символом, который заменяется на подходящий столбец, описывающий пустые символы и положения головок машины $M_h$.
\\
\\
3. $M_f$. По завершении работы $M_w$ начинает работу третья машина $M_f$ , которая восстанавливает на ленте состояние ленты результата машины $M_h$. Она проходит по всем ячейкам рабочей зоны и
заменяет столбец матрицы конфигурации на символ из алфавита A машины $M_h$, если головка
$M_h$ на ленте результата не находится в этом столбце. Затем она возвращается в ту ячейку,
которая соответствует положению головки на ленте результата машины $M_h$, и производит ту
же замену. После этого $M_f$ останавливается с чувством выполненного долга.

\subsection{Эквивалентность следующих утверждений: множество перечислимо, полухарактеристическая функция множества вычислима, множество является областью определения вычислимой функции, множество является проекцией разрешимого множества пар.}

\textbf{Теорема.} Следующие утверждения для непустого $S \subseteq \mathbb{N}$ эквивалентны:

1) S перечислимо (существует печатающая машина, такая, что $\forall x \in S$ x встречается в потоке вывода, $\forall x \notin S$ x не встречается в потоке вывода);

2) Полухарактеристическая функция множества (равная 0 на элементах S и не определённая вне S) вычислима;

3) S - область определения вычислимой функции (если существует алгоритм, её вычисляющий, то
есть такой алгоритм A, что $\forall f(n)$ определённых для некоторого n алгоритм А остановится на входе n и напечатает f(n), иначе - не остановится на входе n);

4) S - проекция разрешимого (существует алгоритм, который по любому натуральному n определяет, принадлежит ли оно множеству) множества пар.

$\blacktriangle$
(1) $\Rightarrow$ (2). Запускаем эту печатающую машину. Если она выдаёт x, то значение полухарактеристической функции 1, иначе - $\perp$.

(2) $\Rightarrow$ (3). S - область определения характеристической функции, описанной ранее.

(3) $\Rightarrow$ (1). Пусть S - область определения вычислимой функции f, вычисляемой алгоритмом B. Тогда есть алгоритм, перечисляющий A: параллельно запускать B на входах 0, 1, 2, ..., делая всё больше шагов (1 шаг на входах 0 и 1, 2 шага - на входах 0, 1, 2, и.т.д.); напечатать все номера, на которых B остановился. 

(1) $\Rightarrow$ (4). S = $\{ x | \exists n (x, n) \in B\}$ - проекция множества $B = \{ (x, n):$ x в первых n шагах алгоритма, перечисляющего S$\}$

(4) $\Rightarrow$ (1). for (x=0;; ++x) \\
for (y=0; y<= x; ++y) 

    $\{ if ((x, y) \in B)$ cout $<<$ x;

    $if ((y, x) \in B)$ cout $<<$ y; $\}$
$\blacksquare$

\subsection{Теорема Поста: критерий разрешимости в терминах перечислимости множества и его дополнения.}
\par \textbf{Теорема:} $A$ разрешимо $\Leftrightarrow$ $A$ и $\overline{A}$ перечислимы
\par \begin{itemize}
    \item[$\blacktriangle \: \Rightarrow$:] $A$ можно перечислить даже по возрастанию. Запустим цикл по $n=0,1, \ldots$ Если $n \in A$ (вычислимо по определению разрешимого множества), то выводим $n$. Дополнение разрешимого множества также разрешимо (возьмем характеристическую функцию $A$ и поменяем местами значения 0 и 1), поэтому оно тоже перечислимо
    \item[$\Leftarrow$:] Покажем как построить характеристическую функцию для $A$. Запускаем цикл по $n=1, 2, \ldots$ \begin{enumerate}
        \item Возвращаем 1, если $x$ было перечислено в $A$ на $n$-ом шаге
        \item Возвращаем 0, если $x$ было перечислено в $\overline{A}$ на $n$-ом шаге
    \end{enumerate}
    \par Для любого $x$ что-то будет выведено, так как оно лежит либо в $A$, либо в $\overline{A}$ и в силу их перечислимости будет перечислено на каком-то шаге $\Rightarrow A$ - разрешимо $\blacksquare$
\end{itemize}

\subsection{Неразрешимость проблем самоприменимости и остановки.}
\par Пусть $U$ - универсальная вычислимая функция
\par \textbf{Проблема самоприменимости:} по входу $p$ нужно понять, определено ли $U(p,p)$.
\par \textbf{Утверждение:} это неразрешимая проблема, т.е. множество $\{p|U(p,p) \text{ определено}\}$ неразрешимо.
\par $\blacktriangle$ Предположим, что это множество разрешимо. Тогда вычислима функция $$d'(x)=\begin{cases}
   U(x,x)+1 &\text{$U(x,x)$ определено}\\
   1 &\text{$U(x,x)$ не определено}
 \end{cases}$$
 \par Тогда так как $d'$ вычислима, то по определению $U$ $\exists p \forall x \: d'(x)=U(p, x)$. Рассмотрим $U(p,p)$. Предположим, что она определена, тогда $U(p,p)=d'(p)=U(p,p)+1$ - противоречие. Если предположим, что она не определена, получим $U(p,p)=d'(p)=1$ - тоже противоречие $\Rightarrow$ это множество неразрешимо $\blacksquare$
\par \textbf{Лемма:} Область определения вычислимой функции перечислима
\par $\blacktriangle$ Построим полухарактеристическую функцию. Запустим $f(x)$ и если оно остановится, вернем 1. Это и будет полухарактеристической функцией области определения (1 - если $f(x)$ определена, $\bot$ - если не определена) $\Rightarrow$ область определения перечислима $\blacksquare$
\par \textbf{Замечание:} Множество из проблемы самоприменимости перечислимо, как область определения вычислимой функции $d(x)=U(x,x)$
\par \textbf{Проблема остановки (останова):} по входу $(p,k)$ нужно понять, определено ли $U(p,k)$.
\par \textbf{Утверждение:} эта проблема тоже неразрешима
\par $\blacktriangle$ Пусть это не так и проблема разрешима. Тогда бы разрешима проблема самоприменимости, так как она является частным случаем проблемы остановки (при $k=p$). Получили противоречие $\Rightarrow$ эта проблема неразрешима $\blacksquare$

\subsection{Несуществование универсальной тотально вычислимой функции.}
\par \textbf{Определение:} $U: \{0,1\}^* \times \{0,1\}^* \Rightarrow \{0,1\}^*$ называется \textit{универсальной тотально вычислимой функцией}, если \begin{enumerate}
    \item $U$ вычислима и всюду определена
    \item  Если $f$ — всюду определённая вычислимая функция одного аргумента, то $\exists p \forall x U(p,x) = f (x)$ 
\end{enumerate}
\par \textbf{Теорема:} Универсальной тотально вычислимой функции не существует
\par $\blacktriangle$ Предположим, что такая функция существует. Тогда рассмотрим функцию $d(x)=U(x, x)$ - всюду определена и вычислима. Тогда функция $d'(x)=U(x,x)+1$ также всюду определена и вычислима. Значит, по определению универсальной тотально вычислимой функции $\exists p \forall x U(p,x)=d'(x)$. Рассмотрим $U(p,p)=d'(p)=U(p,p)+1$ - противоречие $\Rightarrow$ такой функции не существует $\blacksquare$
\par \textbf{Замечание:} Для обычных универсальных вычислимых функций такого противоречие не возникает, так как равенство $U(p,p)=U(p,p)+1$ верно, если $U(p,p)$ не определена

\subsection{Неперечислимость и некоперечислимость множества всюду определённых программ или множества программ с конечной областью определения (на выбор).}
\par$\blacktriangle$ Пусть это множество перечислимо (обозначим его как $A$). Решим с его помощью проблему самоприменимости (см. билет 3.4). Пусть $F$ - исследуемая функция, имеющая номер $n$ в какой то главной универсальной вычислимой функции. 
Тогда $$F'(x) = \begin{cases} 
x & \text{если $F(n)$ не завершилось за $x$ шагов}\\
\bot & \text{иначе не определена}
\end{cases}$$
\par Значит $F'$ всюду определена $\Leftrightarrow$ $F(n)$ не останавливается.
Пусть $F'$ имеет номер $m$. Тогда: \begin{enumerate}
    \item Запустить и сразу остановить $F(n)$
    \item Проделать ещё $1$ шаг в работе $F(n)$. Если $F(n)$ остановилось, вывести $1$
    \item Вывести перечисляющем алгоритмом ещё один элемент множества $A$. Если он равен $m$ (то есть $F'(x) \in A$, а значит всюду определена) вывести $0$
    \item Вернуться ко второму шагу
\end{enumerate}
Так как $F$ или самоприменима, или несамоприменима (ее номер либо лежит в множестве из проблемы самоприменимости, либо нет), то или $1$ или $2$ шаг когда нибудь выведет результат, значит проблема самоприменимости решена, противоречие.
\par Коперечислимость решается аналогично, только $F'(x) = F(n)$ (получается $F'$ не всюду определена (то есть лежит в дополнении к $A$) $\Leftrightarrow$ $F(n)$ не останавливается). Нам остается только заменить в нашем алгоритме третий шаг: будем перечислять $\overline{A}$. $\blacksquare$

\subsection{Существование главной универсальной вычислимой функции.}
\par \textbf{Теорема 1:} Существует вычислимая функция двух аргументов, являющаяся универсальной функцией для класса вычислимых функций одного аргумента.
\par $\blacktriangle$ Запишем все программы, вычисляющие функции одного аргумента, в вычислимую последовательность $p_0, p_1, \ldots$ (например, в порядке возрастания их длины). Положим $U(i, x)$ равным результату работы $i$-ой программы на входе $x$. Тогда функция $U$ и будет искомой вычислимой универсальной функцией. $\blacksquare$ 
\par \textbf{Теорема 2:} Существует главная универсальная функция.
\par $\blacktriangle$ Заметим сначала, что существует вычислимая функция трёх аргументов, универсальная для класса вычислимых функций двух аргументов, то есть такая функция $T$, что при фиксации первого аргумента среди функций $T_n(u, v) = T(n, u, v)$ встречаются все вычислимые функции двух аргументов.
\par Такую функцию можно построить так. Фиксируем некоторую вычислимую нумерацию пар, то есть вычислимое взаимно однозначное соответствие $(u, v) \leftrightarrow [u, v]$ между $\mathbb{N} \times \mathbb{N}$ и $\mathbb{N}$; число $[u, v]$, соответствующее паре $(u, v)$, мы будем называть номером этой пары.
\par Если теперь $R$ — двуместная вычислимая универсальная функция
для вычислимых одноместных функций (существует по теореме 1), то вычислимая функция $T$,
определённая формулой $T(n, u, v) = R(n, [u, v])$, будет универсальной для вычислимых двуместных функций. В самом деле, пусть $F$ —
произвольная вычислимая функция двух аргументов. Рассмотрим
вычислимую одноместную функцию $f$, определённую соотношением $f([u, v]) = F(u, v)$. Поскольку $R$ универсальна, найдётся число $n$,
для которого $R(n, x) = f(x)$ при всех $x$. Для этого $n$ выполнены равенства $T(n, u, v) = R(n, [u, v]) = f([u, v]) = F(u, v)$. Итак, универсальная функция
трёх аргументов построена.
\par Теперь используем её для определения главной универсальной
функции $U$ двух аргументов. Положим $U([n, u], v) = T(n, u, v)$ и проверим, что функция U будет главной. Для любой вычислимой функции $V$ двух аргументов можно найти такое $n$, что $V (u, v) = T(n, u, v)$ (так как $T$ - универсальна) для всех $u$ и $v$. Тогда $V (u, v) = U([n, u], v)$ для всех $u$ и $v$ и потому функция $s$, определённая формулой $s(u) = [n, u]$, удовлетворяет требованиям из
определения главной универсальной функции. $\blacksquare$

\subsection{Теорема Райса–Успенского о неразрешимости нетривиальных свойств вычислимых функций.}
\par \textbf{Теорема Райса-Успенского:} Пусть $A \subset \mathcal{F}$ — произвольное нетривиальное свойство вычислимых функций (нетривиальность означает, что есть как функции, ему удовлетворяющие, так и функции, ему не удовлетворяющие, то есть что множество $A$ непусто и не совпадает со всем $\mathcal{F}$).
Пусть $U$ — главная универсальная функция. Тогда не существует алгоритма, который по $U$-номеру вычислимой функции проверял бы, обладает ли она свойством $A$. Другими словами, множество $S_a=\{n | U_n \in A\}$ неразрешимо.
\par $\blacktriangle$ Пусть $\zeta(x)$ — нигде не определённая функция. Без ограничения общности $\zeta \in  \overline{A}$ (иначе получим неразрешимость $\overline{A}$, которая влечёт неразрешимость $A$)
\par Пусть $\xi(x)$ — какая-то функция из $A$. Пусть $K$ — какое-то перечислимое неразрешимое множество (например, из проблемы самоприменимости)
\par Рассмотрим $$V(n, x) = \begin{cases}
\xi(x) & n \in K\\
\zeta(x) & n \in \overline{K}
\end{cases}$$ Тогда $V$ — вычислимая функция. Программа, вычисляющая $V$: запустить перечисление $K$, ожидать появления $n$. Если появилось, вернуть $\xi(x)$.
\par По определению главной универсальной вычислимой функции (ГУВФ) существует всюду определённая $s$, такая что $\forall n \forall x V(n,x) = U (s(n),x)$
\begin{enumerate}
    \item Если $n \in K$, то $V(n, x)=\xi(x)=U(s(n),x) \Rightarrow s(n)$ - номер функции из $A$
    \item Если $n \in \overline{K}$, то $U(s(n), x)=\zeta(x)$, т.е. $s(n)$ — номер функции из $\overline{A}$.
\end{enumerate}
\par Получаем $n \in K \Leftrightarrow s(n) \in S_a$. При этом $s$ вычислима и всюду определена, так что ситуация подходит под
определение $m$-сводимости (см. определения) $\Rightarrow K \leq_m S_a$. Так как $K$ неразрешимо, то и $S_a$ неразрешимо $\blacksquare$

\subsection{Теорема Клини о неподвижной точке. Построение программы, на любом входе печатающей некоторый собственный номер.}
\par \textbf{Теорема Клини о неподвижной точке:} Пусть $U$ — ГУВФ, $h$ — всюду определённая вычислимая функция. Тогда существует $p$, т.ч. при всех $x$ верно $U(p,x)=U(h(p),x)$
\par $\blacktriangle$ Пусть $V(x,y):=U(U(x,x), y)$. В силу главности $U$ существует вычислимая всюду определенная $s$, такая что $\forall x,y \: V(x,y)=U(s(x), y)$. 
\par Рассмотрим $t(x)=h(s(x))$ - вычислима и всюду определена как композиция вычислимых всюду определенных. Значит $\exists p \forall x \: t(x)=U(p,x)$. Тогда $$U(s(p),y)=V(p,y)=U(U(p,p),y)=U(t(p),y)=U(h(s(p)),y) \Rightarrow U(s(p),y)=U(h(s(p)),y) \Rightarrow $$ $$ \Rightarrow s(p) \text{ - неподвижная точка } \blacksquare$$
\par \textbf{Замечание:} в условии некоторый собственный номер означает какой-то свой номер в ГУВФ (какой-то так как у каждой функции бесконечное количество номеров)
\par \textbf{Утверждение:}  Пусть $U(n, x)$ — главная вычислимая универсальная
функция для класса всех вычислимых функций одного аргумента. Тогда существует такое число $p$, что $U(p, x) = p$ для любого $x$.
\par $\blacktriangle$ Рассмотрим $V(n,x)=n$. Так как $U$ - ГУВФ, то существует вычислимая всюду определенная функция $s$ такая что $U(s(n),x)=V(n,x)$. Тогда по теореме Клини о неподвижной точке существует $p$ такое что $\forall x \: U(p,x)=U(s(p),x)=V(p,x)=p \: \blacksquare$

\subsection{Теорема об арифметической иерархии: $\sum_n \neq \sum_{n+1}, \sum_n \neq \prod_n$.}

\textbf{Опр} \textit{Классы арифметической иерархии}\\
Говорят, что множество $A $ принадлежит классу $\Sigma_n$, если существует такое разрешимое множество $R \in \mathbb{N}^{k+1}$, что \begin{center}
$x \in A \Longleftrightarrow \exists y_1 \ \forall y_2 \ \exists y_3 .... \mathcal{Q} y_n [(x, y_1,...,y_k) \in R]$
\\
\end{center}
Аналогично, говорят, что $A$ принадлежит классу $\Pi_n$, если существует такое разрешимое множество $R \in \mathbb{N}^{k+1}$, что \begin{center}
$x \in A \Longleftrightarrow \forall y_1 \ \exists y_2 \ \forall y_3 .... \mathcal{Q} y_n [(x, y_1,...,y_k) \in R]$
\end{center}

Согласно этому определению, $\Sigma_0 = \Pi_0$(классы $\Sigma_0$ и $\Pi_0$ совпадают с классом всех разрешимых множеств)
\\
$\Sigma_1$ - перечислимые, $\Pi_1$ - коперечислимые
\\

\textbf{Теорема 1}. Для любого n в классе $\sum_n$ существует множество,
универсальное для всех множеств класса $\sum_n$. (Его дополнение будет
универсальным в классе $\prod_n$.)

Говоря о дополнении к $\prod_n$, $\sum_n$  множеству, мы имеем в виду дополнение из множества всех множеств, выражаемых через n предикатов.

Говоря об универсальном множестве из класса $\sum_n$, мы имеем в виду множество пар натуральных чисел, которое принадлежит классу $\sum_n$ и среди сечений которого встречаются все множества натуральных чисел, принадлежащие классу $\sum_n$.

$\blacktriangle$
Для класса $\sum_1$ (перечислимых множеств) существование универсального множества мы уже обсуждали (билет 3.extra6.1) С его помощью можно построить универсальные множества и для более высоких классов иерархии. (Начинать надо с первого уровня, так как на «нулевом» уровне не существует универсального разрешимого множества.)

По определению свойства класса $\prod_2$ имеют вид $\forall y\exists z R(x, y, z)$,
где R — некоторое разрешимое свойство. Но их можно эквивалентно определить и как свойства вида $\forall y P(x, y)$, где P — некоторое перечислимое свойство. Теперь уже видно, как построить универсальное множество класса $\prod_2$. Возьмём универсальное перечислимое свойство U(n, x, y), из которого фиксацией различных n получаются все перечислимые свойства пар натуральных чисел. Тогда из свойства $T(n, x) = \forall y U(n, x, y)$ при различных натуральных n получаются все $\prod_2$-свойства натуральных чисел. С другой стороны, само свойство T по построению принадлежит классу $\prod_2$.

Дополнение к универсальному $\prod_2$-множеству будет, очевидно, универсальным $\sum_2$-множеством - так как отрицание чего-либо меняет все кванторы на противоположные, благодаря чему и само множество, и все его сечения по такому свойству также принадлежат $\sum_2$ - значит, это универсальное $\sum_2$-множество.

Аналогично можно действовать и для $\sum_n$- и $\prod_n$-множеств.
$\blacksquare$ \\
\\
\textbf{Теорема 2.} Универсальное $\sum_n$-множество не принадлежит классу $\prod_n$. Аналогичным образом, универсальное $\prod_n$-множество не принадлежит классу $\sum_n$.

$\blacktriangle$
Рассмотрим универсальное $\sum_n$-свойство $T(m, x)$. По определению это означает, что среди его сечений (получающихся, если зафиксировать m) есть все $\sum_n$-свойства. Пусть T принадлежит классу $\prod_n$. Тогда его диагональ, свойство $D(x) = T(x, x)$, также лежит в $\prod_n$ (например, потому, что $D \leqslant_m T$), а её отрицание, свойство $\neg D(x)$, принадлежит классу $\sum_n$. Но этого не может быть, так как $\neg D$ отлично от всех сечений свойства T (оно отличается от m-го сечения в точке m), а T универсально.
$\blacksquare$

Если $\sum_n = \sum_{n+1}$, то $\prod_{n+1} = \prod_n$ (как отрицание $\sum_n$ и $\sum_{n+1}$). Т.к. $\sum_n \subset \prod_{n+1} = \prod_n$, а $\prod_n \subset \sum_{n+1} = \sum_n$, то $\sum_{n+1} = \prod_{n+1}$, что противоречит теореме выше. Основная теорема доказана. 

\subsection{Теорема Чёрча-Россера (б/д). Единственность нормальной формы.}

\begin{theorem}[Чёрча-Россера (б/д)]
    Если для некоторого $\lambda$-терма $A$ имеется два варианта редукции $A \rightarrow B$ и $A \rightarrow C$, то существует такой $\lambda$-терм $D$, что $B \rightarrow D$ и $C \rightarrow D$.
\end{theorem}

\begin{definition}
    Термы $M$ и $N$ называются равными, если существует такой терм $T$, что $M$ сводится (некоторым количеством $\alpha$ и $\beta$ редукций) к $T$ и $N$ сводится к $T$.
\end{definition}

\begin{definition}
    Говорят, что терм $M$ находится в \textit{нормальной форме}, если к нему нельзя применить $\beta$-редукцию даже после нескольких $\alpha$-конверсий.\\
    Говорят, что $N$ -- \textit{нормальная форма} терма $M$, если $M=N$ и $N$ в нормальной форме.
\end{definition}

\begin{corollary}[из теоремы Чёрча-Россера]
    У каждого $\lambda$-терма есть не более одной нормальной формы.
    
    \begin{proof}
        Предположим, что у терма $A$ две нормальные формы: $B$ и $C$ (то есть $A \rightarrow B$ и $A \rightarrow C$). По теореме Чёрча-Россера существует такой $D$, что $B \rightarrow D$ и $C \rightarrow D$. Но по определению $B$ и $C$ -- $\lambda$-термы, к которым нельзя применить $\beta$-редукцию. Противоречие.
    \end{proof}
    
\end{corollary}

\begin{note}
    Не у всех $\lambda$-термов есть нормальная форма. Например, $\Omega = (\lambda x.xx)(\lambda x.xx)$ редуцируется сам в себя.
\end{note}

\subsection{Построение комбинаторов логических значений, булевых функций, операций с парами, проверки на ноль для нумералов Чёрча (с доказательством корректности).}
    
\begin{definition}
    \textit{Комбинатором} называется замкнутый $\lambda$-терм (без свободных переменных).
\end{definition}

\textbf{Представление логических значений и булевых функций}\\

Пусть
$$
    False = \lambda xy.y (= \overline{0})
$$
$$
    True = \lambda xy.x
$$
Получается, что
$$
    True \: M \: N = M
$$
$$
    False \: M \: N = N
$$
Тогда логические функции выражаются следующим образом:
$$
    And = \lambda pq.pqp
$$
$$
    Or = \lambda pq.ppq
$$
$$
    Not = \lambda p.p \: False \: True
$$

\begin{proof}*\\
    1) $And = \lambda pq.pqp$\\
    Если $p = 0$, то $p \wedge q = 0 = p$\\
    Если $p = 1$, то $p \wedge q = q$\\
    2) $Or = \lambda pq.ppq$\\
    Если $p = 0$, то $p \lor q = q$\\
    Если $p = 1$, то $p \lor q = 1 = p$\\
    3) $Not = \lambda p.p \: False \: True$\\
    Если $p = False$, то $False \: False \: True = True$
    Если $p = True$, то $True \: False \: True = False$
\end{proof}


\textbf{Представление арифметических опреаций на нумералах Чёрча}\\

1) $Inc$ -- прибавление единицы ($Inc \overline{n} = \overline{n + 1}$)\\

$Inc = \lambda nfx.f(nfx)$\\

\begin{proof}
    $
        Inc \overline{n} = (\lambda nfx.f(nfx)) \overline{n} = \lambda fx. f(\overline{n}fx) = \lambda fx.f(\lambda gy.\underbrace{g(g(g(...)))}_{n \text{раз}} fx) = \lambda fx. \underbrace{f(f(f(...(f(fx))...)))}_{n + 1 \text{раз}} = \overline{n + 1}
    $
\end{proof}

2) $Add$ -- сложение\\

$Add = \lambda mnfx.mf(nfx)$\\

\begin{proof}*\\
    $
    Add \: \overline{m} \: \overline{n} = (\lambda mnfx.mf(nfx)) \: \overline{m} \: \overline{n} = \lambda fx. \overline{m}f(\overline{n}fx) = \lambda fx. (\lambda gy. \underbrace{g(g(g(...)))}_{m \text{раз}}) f (\underbrace{f(f(...))}_{n \text{раз}}) = \lambda fx. \underbrace{f(f(f(...)))}_{m + n \text{раз}} = \overline{m + n}
    $
\end{proof}

3) $Mult$ -- умножение\\

$Mult = \lambda mnfx.m(nf)x$\\

Доказательство аналогично.\\

\textbf{Проверка на ноль для нумералов Чёрча}
$$
    IsZero = \lambda n.n (\lambda x.False) True
$$
Проверим для нуля:
$$
    IsZero \overline{0} = \overline{0} (\lambda x.False)True = True
$$
Любое число, кроме нуля представимо в виде: $\overline{n + 1}$. Проверим $IsZero$ для таких чисел:
$$
    IsZero(\overline{n + 1}) = \overline{n + 1} (\lambda x. False) True = (\lambda fx.f(...)) (\lambda x. False) True = ((\lambda x. False)(...)) = False 
$$